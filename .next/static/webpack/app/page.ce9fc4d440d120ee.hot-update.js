"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.js":
/*!*********************!*\
  !*** ./app/page.js ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcUserHasPinchZoomed: () => (/* binding */ calcUserHasPinchZoomed),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useSessionStateStore: () => (/* binding */ useSessionStateStore),\n/* harmony export */   useUserSettingsStore: () => (/* binding */ useUserSettingsStore),\n/* harmony export */   worksheets: () => (/* binding */ worksheets)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/.pnpm/zustand@5.0.3_react@19.0.0/node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _components_WorksheetViewer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/WorksheetViewer.js */ \"(app-pages-browser)/./app/components/WorksheetViewer.js\");\n/* harmony import */ var _components_SettingsPage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/SettingsPage.js */ \"(app-pages-browser)/./app/components/SettingsPage.js\");\n/* harmony import */ var _stores_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stores.js */ \"(app-pages-browser)/./app/stores.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/./app/constants.js\");\n/* __next_internal_client_entry_do_not_use__ calcUserHasPinchZoomed,useSessionStateStore,useUserSettingsStore,worksheets,default auto */ \nvar _s = $RefreshSig$();\n//     ikeb108.github.io/sam_browser/out\n\n\n\n\n\n\n\n//Keys in allPages use PascalCasing to match the react component names\nconst allPages = {\n    \"WorksheetViewer\": /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_WorksheetViewer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n        fileName: \"C:\\\\Users\\\\qwert\\\\Documents\\\\00_Coding\\\\sam_browser\\\\sam_browser\\\\app\\\\page.js\",\n        lineNumber: 13,\n        columnNumber: 22\n    }, undefined),\n    \"SettingsPage\": /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SettingsPage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n        fileName: \"C:\\\\Users\\\\qwert\\\\Documents\\\\00_Coding\\\\sam_browser\\\\sam_browser\\\\app\\\\page.js\",\n        lineNumber: 14,\n        columnNumber: 19\n    }, undefined)\n};\n/*\r\ncreate() is a method from the zustand module for emulating global variables.\r\n(Simpler alternative to useContext, useState, and redux).\r\n\r\ncreate() returns a \"store hook\"--a function which, when called, returns a \"store\".\r\nThe \"store\" is a state container, an object which can have any properties you want.\r\nThese properties could store data or could be updater functions (called \"actions\"), \r\nwhich can change as many or as few data properties as we want.\r\n\r\ncreate() accepts a function (a \"store initializer\"). The store initializer return an object\r\nwhich has all the properties and actions we want our store to have.\r\n\r\n\"Store hooks\" should be declared with const in the global scope.\r\nThey can be attached to the \"window\" object to make them accessible in the browser console.\r\n\"Store hooks\" can only be *called* inside a React component (React hooks are meant to trigger a component re-render).\r\nTo access the store outside a component, call myStoreHook.getState(). From there, you can read\r\nthe store's properties and call the store's actions.\r\n\r\n*/ // const createAllStudentsStore = function(set){ //Store initializer\n//   /*Zustand passes a \"set\" function into here. We call \"set\"\n//   to update any properties in the store. When we call \"set\", we pass \"set\"\n//   a function which returns a \"partial state\", an object containing any of the properties of the store\n//   we want to change.\n//   We can optionally make that function take the previous state as a parameter.\n//   */\n//   const getAllStudentsFromLocalStorage = function(){\n//     /*This function defines the logic for the initAllStudents action (see below).\n//     This function doesn't require the previous state as a parameter.\n//     This function returns a \"partial state\" which updates the \"allStudents\" property of the store.\n//     */\n//     let allStudentsInLocalStorage = localStorage.getItem(\"allStudents\")\n//     if(allStudentsInLocalStorage !== null){\n//       //console.log(\"Found allStudents in local storage.\")\n//       return { allStudents: JSON.parse(allStudentsInLocalStorage) }\n//     } else {\n//       //console.log(\"Didn't find allStudents in local storage.\")\n//       return { allStudents: {} }\n//     }\n//   }\n//   const setAllStudentsToValue = function( newValue ){\n//     return { allStudents: newValue }\n//   }\n//   return {\n//     allStudents: {},\n//     initAllStudents: ()=> { set(getAllStudentsFromLocalStorage) }, //Action\n//     /*\n//     The initAllStudents() action is called in HomePage(), when the HomePage component\n//     is mounted for the first time. To do this, we use HomePage's useEffect() hook, pass in a function\n//     that calls initAllStudents(), and also pass in an empty dependency array [], which tells React to only\n//     run that function once when the component is mounted.\n//     */\n//    setAllStudents: (newValue) => { set( setAllStudentsToValue(newValue) ) },\n//   }\n// }\n// const useAllStudentsStore = create(createAllStudentsStore) //Returns a store hook\n//Filler data for debugging\n// const fillerStudentData = {\n//   \"1\": { //id number for the student (to avoid glitches w same-name students)\n//     \"name\": \"Student 1\",\n//     \"color\": \"pink\"\n//   },\n//   \"2\": {\n//     \"name\": \"Student 2\",\n//     \"color\": \"purple\"\n//   },\n//   \"3\": {\n//     \"name\": \"Student 3\",\n//     \"color\": \"blue\"\n//   }\n// }\n// const fillerStudentData = {}\n// if(true){\n//   let colorCycle = \"red orange yellow green cyan blue purple pink\".split(\" \")\n//   for(let i = 1; i < 100; i ++){\n//     fillerStudentData[i] = {\n//       \"name\": \"Student \" + i,\n//       \"color\": colorCycle[ (i-1) % colorCycle.length]\n//     }\n//   }\n// }\n// useAllStudentsStore.getState().setAllStudents(fillerStudentData)\nconst useSessionStateStore = (0,zustand__WEBPACK_IMPORTED_MODULE_6__.create)((set)=>({\n        // openStudents: {\n        //   \"2\": {\n        //     \"openWorksheets\": [],\n        //     \"positionInWorksheetSelectionPanel\": 0\n        //   },\n        //   \"1\": {\n        //     \"openWorksheets\": [],\n        //     \"positionInWorksheetSelectionPanel\": 1\n        //   }\n        // },\n        // highestPositionInWorksheetSelectionPanel: 1,\n        // deleteOpenStudent: (studentIDNumber)=>{\n        //   let newOpenStudents = {...useSessionStateStore.getState().openStudents}\n        //   delete newOpenStudents[studentIDNumber]\n        //   set( ()=>({ openStudents: newOpenStudents }) )\n        // },\n        // addOpenStudentToBottom: (studentIDNumber)=>{\n        //   let newOpenStudents = {...useSessionStateStore.getState().openStudents}\n        //   let highestPositionInWorksheetSelectionPanel = useSessionStateStore.getState().highestPositionInWorksheetSelectionPanel\n        //   let newOpenStudent = {\n        //     \"openWorksheets\": [],\n        //     \"positionInWorksheetSelectionPanel\": highestPositionInWorksheetSelectionPanel + 1\n        //   }\n        //   newOpenStudents[studentIDNumber] = newOpenStudent\n        //   set( ()=>({ openStudents: newOpenStudents }) )\n        //   set( () => ({ highestPositionInWorksheetSelectionPanel: highestPositionInWorksheetSelectionPanel + 1 }) )\n        // }\n        // openStudents: [\n        //   {\"openWorksheets\": [], \"studentIDNumber\": \"1\"},\n        //   {\"openWorksheets\": [], \"studentIDNumber\": \"2\"},\n        //   {\"openWorksheets\": [], \"studentIDNumber\": \"3\"},\n        //   {\"openWorksheets\": [], \"studentIDNumber\": \"other\"}\n        // ],\n        openStudents: [\n            {\n                openWorksheets: [],\n                type: \"student\",\n                name: \"Student 1\",\n                color: \"red\"\n            },\n            {\n                openWorksheets: [],\n                type: \"student\",\n                name: \"Student 2\",\n                color: \"orange\"\n            },\n            {\n                openWorksheets: [],\n                type: \"student\",\n                name: \"Student 3\",\n                color: \"yellow\"\n            },\n            {\n                openWorksheets: [],\n                type: \"other\",\n                name: \"Other\",\n                color: \"none\"\n            }\n        ],\n        numberInNameOfLastStudentAdded: 3,\n        setOpenStudents: (newValue)=>{\n            set(()=>({\n                    openStudents: newValue\n                }));\n            useSessionStateStore.getState().saveToLocalStorage();\n        },\n        deleteOpenStudent: (indexInOpenStudents)=>{\n            /*\r\n    When deleting a student, we need to update the openStudentIndex of the currentWorksheet\r\n    because the openStudents array will be shorter after the student is deleted.\r\n    To do this, we'll subtract one from the index of the currentWorksheet.openStudentIndex if\r\n    it is greater than the index of the student being deleted.\r\n    */ const indexOfStudentWithCurrentWorksheet = useSessionStateStore.getState().currentWorksheet.openStudentIndex;\n            if (indexOfStudentWithCurrentWorksheet == indexInOpenStudents) {\n                //If the student we're deleting is the student with the currently open worksheet, set to null\n                useSessionStateStore.getState().setCurrentWorksheet(null, null);\n            }\n            if (indexOfStudentWithCurrentWorksheet !== null && indexOfStudentWithCurrentWorksheet > indexInOpenStudents) {\n                // If the currentWorksheet's openStudentIndex is greater than the index of the student being deleted,\n                // decrement it by 1 to maintain the correct index in the openStudents array.\n                const newCurrentWorksheet = {\n                    ...useSessionStateStore.getState().currentWorksheet\n                };\n                newCurrentWorksheet.openStudentIndex = indexOfStudentWithCurrentWorksheet - 1;\n                set(()=>({\n                        currentWorksheet: newCurrentWorksheet\n                    }));\n            }\n            // Delete the student at indexInOpenStudents from openStudents array\n            let newOpenStudents = [\n                ...useSessionStateStore.getState().openStudents\n            ];\n            newOpenStudents.splice(indexInOpenStudents, 1); //Remove the student at the specified index\n            set(()=>({\n                    openStudents: newOpenStudents\n                }));\n            useSessionStateStore.getState().saveToLocalStorage();\n        },\n        addOpenStudentToBottom: (studentName, color)=>{\n            const newStudentData = {\n                openWorksheets: [],\n                type: \"student\",\n                name: studentName,\n                color: color\n            };\n            //Add newStudentData as second to last student in openStudents\n            let newOpenStudents = [\n                ...useSessionStateStore.getState().openStudents\n            ];\n            newOpenStudents.splice(newOpenStudents.length - 1, 0, newStudentData);\n            set(()=>({\n                    openStudents: newOpenStudents\n                }));\n            useSessionStateStore.getState().saveToLocalStorage();\n        },\n        currentPage: \"WorksheetViewer\",\n        setCurrentPage: (newValue)=>{\n            set(()=>({\n                    currentPage: newValue\n                }));\n            useSessionStateStore.getState().saveToLocalStorage();\n        },\n        currentWorksheet: {\n            openStudentIndex: null,\n            worksheetIndex: null\n        },\n        setCurrentWorksheet: (openStudentIndex, worksheetIndex)=>{\n            set(()=>({\n                    currentWorksheet: {\n                        openStudentIndex: openStudentIndex,\n                        worksheetIndex: worksheetIndex\n                    }\n                }));\n            useSessionStateStore.getState().saveToLocalStorage();\n        },\n        getCurrentWorksheetID: ()=>{\n            const { openStudents, currentWorksheet } = useSessionStateStore.getState();\n            if (currentWorksheet.openStudentIndex === null || currentWorksheet.worksheetIndex === null) return null;\n            return openStudents[currentWorksheet.openStudentIndex].openWorksheets[currentWorksheet.worksheetIndex].id;\n        },\n        userIsMovingCurrentWorksheet: false,\n        setUserIsMovingCurrentWorksheet: (newValue)=>{\n            set(()=>({\n                    userIsMovingCurrentWorksheet: newValue\n                }));\n        },\n        userCanClickAnywhereToDisableMovingCurrentWorksheet: false,\n        setUserCanClickAnywhereToDisableMovingCurrentWorksheet: (newValue)=>{\n            set(()=>({\n                    userCanClickAnywhereToDisableMovingCurrentWorksheet: newValue\n                }));\n        },\n        currentPageOfWorksheet: 0,\n        setCurrentPageOfWorksheet: (newValue)=>{\n            set(()=>({\n                    currentPageOfWorksheet: newValue\n                }));\n            const { openStudents, currentWorksheet } = useSessionStateStore.getState();\n            if (currentWorksheet.openStudentIndex !== null && currentWorksheet.worksheetIndex !== null) {\n                openStudents[currentWorksheet.openStudentIndex].openWorksheets[currentWorksheet.worksheetIndex].pageLeftOff = newValue;\n                set({\n                    openStudents: [\n                        ...openStudents\n                    ]\n                });\n            }\n            useSessionStateStore.getState().saveToLocalStorage();\n        },\n        allowArrowKeysForPageNavigation: true,\n        setAllowArrowKeysForPageNavigation: (newValue)=>{\n            set(()=>({\n                    allowArrowKeysForPageNavigation: newValue\n                }));\n        },\n        saveToLocalStorage: ()=>{\n            const sessionState = useSessionStateStore.getState();\n            //Store only the following values in local storage\n            const partialSessionState = {\n                openStudents: sessionState.openStudents,\n                currentPage: sessionState.currentPage,\n                currentWorksheet: sessionState.currentWorksheet,\n                currentPageOfWorksheet: sessionState.currentPageOfWorksheet\n            };\n            localStorage.setItem(\"sessionState\", JSON.stringify(partialSessionState));\n        },\n        loadFromLocalStorage: ()=>{\n            const sessionStateFromLocalStorage = localStorage.getItem(\"sessionState\");\n            if (sessionStateFromLocalStorage !== null) {\n                console.log(\"loading sessionstate from local storage\");\n                const partialSessionState = JSON.parse(sessionStateFromLocalStorage);\n                set(()=>({\n                        openStudents: partialSessionState.openStudents,\n                        currentPage: partialSessionState.currentPage,\n                        currentWorksheet: partialSessionState.currentWorksheet,\n                        currentPageOfWorksheet: partialSessionState.currentPageOfWorksheet\n                    }));\n            }\n        }\n    }));\nconst useUserSettingsStore = (0,zustand__WEBPACK_IMPORTED_MODULE_6__.create)((set)=>({\n        //settings go here\n        pageView: \"double\",\n        setPageView: (newValue)=>{\n            set(()=>({\n                    pageView: newValue\n                }));\n        },\n        madisonMode: false,\n        setMadisonMode: (newValue)=>{\n            set(()=>({\n                    madisonMode: newValue\n                }));\n        }\n    }));\nfunction calcUserHasPinchZoomed() {\n    //calculates whether the user has pinch zoomed on the page\n    return window.visualViewport.scale !== 1;\n}\nfunction updateUserHasPinchZoomedOnResize() {\n    //If the user has pinch zoomed, set the store to true,\n    //but only if it's not already set to true. Otherwise, setting it to true\n    //would cause unnecessary rerenders of the entire HomePage during every frame of pinch zoom gesture.\n    if (calcUserHasPinchZoomed()) {\n        if (!_stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore.getState().userHasPinchZoomed) {\n            _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore.getState().setUserHasPinchZoomed(true);\n        }\n    }\n//If the user has not pinch zoomed, the userHasPinchZoomed state shouldn't be set to false until touchend.\n//Otherwise, the user could trigger drag events while pinch zooming if it's zoomed all the way out.\n}\nconst worksheets = {};\nfunction HomePage() {\n    _s();\n    const { userHasPinchZoomed } = (0,_stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore)();\n    const { pageView } = useUserSettingsStore();\n    //The function in this useEffect will run every time HomePage is rerendered,\n    //which will happen every time userHasPinchZoomed changes, which should be\n    //at the start and end of pinch zoom gestures, but not in between.\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"HomePage.useEffect\": ()=>{\n            //These event listeners get added every time the component is rerendered.\n            //To prevent event listeners from accumulating, they get removed when the component unmounts\n            //via the cleanup function that is returned below.\n            window.visualViewport.addEventListener(\"resize\", updateUserHasPinchZoomedOnResize);\n            document.addEventListener(\"touchend\", onDocumentTouchEndOrMouseUp);\n            document.addEventListener(\"mouseup\", onDocumentTouchEndOrMouseUp);\n            updateUserHasPinchZoomedOnResize();\n            if (window.location.href.includes(\"?eruda=true\")) {\n                /*\r\n      Eruda is a module for adding virtual devtools to a webpage for mobile debugging.\r\n      Eruda expects to be run in-browser, so it needs to be imported dynamically\r\n      from within a component like HomePage with useEffect. It's not enough to\r\n      just import it at the top of a file that says 'use client'.\r\n      The reason that we're importing this differently from how Eruda recommends\r\n      in docs is because Eruda doesn't necessarily expect to be used in a\r\n      React/Nextjs app.\r\n      \r\n      For Android, we can use chrome://inspect/#devices to do remote debugging for\r\n      Chrome, but not for other browsers.\r\n      https://developer.chrome.com/docs/devtools/remote-debugging\r\n      \r\n      However, the port-forwarding feature of chrome://inspect/#devices can be\r\n      used on any web browser on the Android device, which allows us to run the\r\n      webpage from \"npm run dev\" instead of having to build first.\r\n      \r\n      ^ It seems like this often requires opening the page in Chrome first before\r\n      then opening the page in the other browser for some reason.\r\n      */ __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_eruda_3_4_1_node_modules_eruda_eruda_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! eruda */ \"(app-pages-browser)/./node_modules/.pnpm/eruda@3.4.1/node_modules/eruda/eruda.js\", 23)).then({\n                    \"HomePage.useEffect\": (module)=>{\n                        module.default.init();\n                    }\n                }[\"HomePage.useEffect\"]);\n            }\n            // window.eruda = eruda\n            return ({\n                \"HomePage.useEffect\": ()=>{\n                    window.visualViewport.removeEventListener(\"resize\", updateUserHasPinchZoomedOnResize);\n                    document.removeEventListener(\"touchend\", onDocumentTouchEndOrMouseUp);\n                    document.removeEventListener(\"mouseup\", onDocumentTouchEndOrMouseUp);\n                }\n            })[\"HomePage.useEffect\"];\n        }\n    }[\"HomePage.useEffect\"], []);\n    const homePageStyle = {\n        fontFamily: \"Roboto, sans-serif\",\n        fontWeight: \"normal\",\n        fontSize: \"18px\",\n        height: \"100%\",\n        width: \"100%\",\n        maxWidth: pageView == \"double\" ? \"1500px\" : \"1000px\",\n        color: _constants_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].nearBlackColor,\n        // touchAction: userHasPinchZoomed ? \"auto\" : \"pinch-zoom\", \n        margin: \"0 auto\"\n    };\n    // const sessionStateStore = useSessionStateStore()\n    const currentPage = useSessionStateStore({\n        \"HomePage.useSessionStateStore[currentPage]\": (state)=>state.currentPage\n    }[\"HomePage.useSessionStateStore[currentPage]\"]);\n    if (currentPage == \"WorksheetViewer\") {\n        homePageStyle.touchAction = userHasPinchZoomed ? \"auto\" : \"pinch-zoom\" //If the user has pinch zoomed, allow panning. If not, disable panning\n        ;\n    }\n    /*\r\n  When HomePage mounts for the first time, initialize allStudentsStore by grabbing\r\n  allStudents from localStorage. Pass an empty dependency array [] into useEffect to tell React\r\n  to only run this code the first time HomePage mounts.\r\n  */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"HomePage.useEffect\": ()=>{\n            //useAllStudentsStore.getState().initAllStudents();\n            window.useSessionStateStore = useSessionStateStore;\n            window.useUserSettingsStore = useUserSettingsStore;\n            //On page load, retrieve worksheets from IndexedDB if any. This function is imported from SettingsPage.js\n            (0,_components_SettingsPage_js__WEBPACK_IMPORTED_MODULE_3__.retrieveWorksheetsFromIndexedDB)();\n        }\n    }[\"HomePage.useEffect\"], []);\n    /*\r\n  The dependency array we pass into useEffect tells React which variables to look\r\n  for changes in. When any of these variables change, the function in useEffect() is\r\n  triggered. Empty = run only once (on component mount).\r\n  */ const onClick = function() {\n        if (currentPage == \"WorksheetViewer\") {\n            const { userIsMovingCurrentWorksheet, userCanClickAnywhereToDisableMovingCurrentWorksheet } = useSessionStateStore.getState();\n            const { userJustClickedMove } = _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserJustClickedMoveStore.getState();\n            if (!userJustClickedMove && userIsMovingCurrentWorksheet && userCanClickAnywhereToDisableMovingCurrentWorksheet) {\n                const { setUserIsMovingCurrentWorksheet, setUserCanClickAnywhereToDisableMovingCurrentWorksheet } = useSessionStateStore.getState();\n                setUserIsMovingCurrentWorksheet(false);\n                setUserCanClickAnywhereToDisableMovingCurrentWorksheet(false);\n            }\n        // if(sessionStateStore.userIsMovingCurrentWorksheet && sessionStateStore.userCanClickAnywhereToDisableMovingCurrentWorksheet){\n        //   console.log(\"set to false\")\n        //   sessionStateStore.setUserIsMovingCurrentWorksheet(false)\n        //   sessionStateStore.setUserCanClickAnywhereToDisableMovingCurrentWorksheet(false)\n        // }\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: homePageStyle,\n        onClick: onClick,\n        children: allPages[currentPage]\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\qwert\\\\Documents\\\\00_Coding\\\\sam_browser\\\\sam_browser\\\\app\\\\page.js\",\n        lineNumber: 381,\n        columnNumber: 5\n    }, this);\n}\n_s(HomePage, \"yxx9c7NOQrvQ1a8jmkeW3XNjpAA=\", false, function() {\n    return [\n        _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore,\n        useUserSettingsStore,\n        useSessionStateStore\n    ];\n});\n_c = HomePage;\nconst onDocumentTouchEndOrMouseUp = function() {\n    updateUserHasPinchZoomedIfChanged(false);\n};\nfunction updateUserHasPinchZoomedIfChanged(callAgainBoolean) {\n    //Update userhaspinchzoomed store, but only if the value has changed.\n    //(to prevent unnecessary rerenders)\n    const newUserHasPinchZoomed = calcUserHasPinchZoomed();\n    const oldUserHasPinchZoomed = _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore.getState().userHasPinchZoomed;\n    if (oldUserHasPinchZoomed !== newUserHasPinchZoomed) {\n        _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore.getState().setUserHasPinchZoomed(newUserHasPinchZoomed);\n    }\n    if (callAgainBoolean) setTimeout(updateUserHasPinchZoomedIfChanged(false), 1000);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HomePage);\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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QUFxQlUsUUFBUTtnQkFDaklxQixnQ0FBZ0M7Z0JBQ2hDRSx1REFBdUQ7WUFDekQ7UUFDQSwrSEFBK0g7UUFDL0gsZ0NBQWdDO1FBQ2hDLDZEQUE2RDtRQUM3RCxvRkFBb0Y7UUFDcEYsSUFBSTtRQUNOO0lBQ0Y7SUFDQSxxQkFDRSw4REFBQ3dEO1FBQUlDLE9BQU9kO1FBQWVXLFNBQVNBO2tCQUNqQ3hGLFFBQVEsQ0FBQzBCLFlBQVk7Ozs7OztBQUc1QjtHQXhHU3VDOztRQUN3QnBFLGtFQUEwQkE7UUFDcEN1RDtRQTBERG5EOzs7S0E1RGJnRTtBQTBHVCxNQUFNRyw4QkFBOEI7SUFDbEN3QixrQ0FBa0M7QUFDcEM7QUFFQSxTQUFTQSxrQ0FBbUNDLGdCQUFnQjtJQUMxRCxxRUFBcUU7SUFDckUsb0NBQW9DO0lBQ3BDLE1BQU1DLHdCQUF3QnJDO0lBQzlCLE1BQU1zQyx3QkFBd0JsRyxrRUFBMEJBLENBQUNjLFFBQVEsR0FBR21ELGtCQUFrQjtJQUN0RixJQUFHaUMsMEJBQTBCRCx1QkFBc0I7UUFDakRqRyxrRUFBMEJBLENBQUNjLFFBQVEsR0FBR29ELHFCQUFxQixDQUFDK0I7SUFDOUQ7SUFDQSxJQUFHRCxrQkFBa0JHLFdBQVlKLGtDQUFrQyxRQUFRO0FBQzdFO0FBRWlFO0FBQ2pFLGlFQUFlM0IsUUFBUUEsRUFBQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxxd2VydFxcRG9jdW1lbnRzXFwwMF9Db2RpbmdcXHNhbV9icm93c2VyXFxzYW1fYnJvd3NlclxcYXBwXFxwYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG4vLyAgICAgaWtlYjEwOC5naXRodWIuaW8vc2FtX2Jyb3dzZXIvb3V0XHJcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCdcclxuaW1wb3J0IFdvcmtzaGVldFZpZXdlciBmcm9tICcuL2NvbXBvbmVudHMvV29ya3NoZWV0Vmlld2VyLmpzJ1xyXG5pbXBvcnQgU2V0dGluZ3NQYWdlIGZyb20gJy4vY29tcG9uZW50cy9TZXR0aW5nc1BhZ2UuanMnXHJcbmltcG9ydCB7IHJldHJpZXZlV29ya3NoZWV0c0Zyb21JbmRleGVkREIsIHNldFN0YXR1c01lc3NhZ2VPZldvcmtzaGVldFByb2Nlc3MgfSBmcm9tIFwiLi9jb21wb25lbnRzL1NldHRpbmdzUGFnZS5qc1wiXHJcbmltcG9ydCB7IHVzZVVzZXJIYXNQaW5jaFpvb21lZFN0b3JlLCB1c2VVc2VySnVzdENsaWNrZWRNb3ZlU3RvcmUgfSBmcm9tIFwiLi9zdG9yZXMuanNcIlxyXG5pbXBvcnQgY29uc3RhbnRzIGZyb20gXCIuL2NvbnN0YW50cy5qc1wiXHJcblxyXG4vL0tleXMgaW4gYWxsUGFnZXMgdXNlIFBhc2NhbENhc2luZyB0byBtYXRjaCB0aGUgcmVhY3QgY29tcG9uZW50IG5hbWVzXHJcbmNvbnN0IGFsbFBhZ2VzID0ge1xyXG4gIFwiV29ya3NoZWV0Vmlld2VyXCI6IDxXb3Jrc2hlZXRWaWV3ZXIgLz4sXHJcbiAgXCJTZXR0aW5nc1BhZ2VcIjogPFNldHRpbmdzUGFnZSAvPlxyXG59XHJcblxyXG4vKlxyXG5jcmVhdGUoKSBpcyBhIG1ldGhvZCBmcm9tIHRoZSB6dXN0YW5kIG1vZHVsZSBmb3IgZW11bGF0aW5nIGdsb2JhbCB2YXJpYWJsZXMuXHJcbihTaW1wbGVyIGFsdGVybmF0aXZlIHRvIHVzZUNvbnRleHQsIHVzZVN0YXRlLCBhbmQgcmVkdXgpLlxyXG5cclxuY3JlYXRlKCkgcmV0dXJucyBhIFwic3RvcmUgaG9va1wiLS1hIGZ1bmN0aW9uIHdoaWNoLCB3aGVuIGNhbGxlZCwgcmV0dXJucyBhIFwic3RvcmVcIi5cclxuVGhlIFwic3RvcmVcIiBpcyBhIHN0YXRlIGNvbnRhaW5lciwgYW4gb2JqZWN0IHdoaWNoIGNhbiBoYXZlIGFueSBwcm9wZXJ0aWVzIHlvdSB3YW50LlxyXG5UaGVzZSBwcm9wZXJ0aWVzIGNvdWxkIHN0b3JlIGRhdGEgb3IgY291bGQgYmUgdXBkYXRlciBmdW5jdGlvbnMgKGNhbGxlZCBcImFjdGlvbnNcIiksIFxyXG53aGljaCBjYW4gY2hhbmdlIGFzIG1hbnkgb3IgYXMgZmV3IGRhdGEgcHJvcGVydGllcyBhcyB3ZSB3YW50LlxyXG5cclxuY3JlYXRlKCkgYWNjZXB0cyBhIGZ1bmN0aW9uIChhIFwic3RvcmUgaW5pdGlhbGl6ZXJcIikuIFRoZSBzdG9yZSBpbml0aWFsaXplciByZXR1cm4gYW4gb2JqZWN0XHJcbndoaWNoIGhhcyBhbGwgdGhlIHByb3BlcnRpZXMgYW5kIGFjdGlvbnMgd2Ugd2FudCBvdXIgc3RvcmUgdG8gaGF2ZS5cclxuXHJcblwiU3RvcmUgaG9va3NcIiBzaG91bGQgYmUgZGVjbGFyZWQgd2l0aCBjb25zdCBpbiB0aGUgZ2xvYmFsIHNjb3BlLlxyXG5UaGV5IGNhbiBiZSBhdHRhY2hlZCB0byB0aGUgXCJ3aW5kb3dcIiBvYmplY3QgdG8gbWFrZSB0aGVtIGFjY2Vzc2libGUgaW4gdGhlIGJyb3dzZXIgY29uc29sZS5cclxuXCJTdG9yZSBob29rc1wiIGNhbiBvbmx5IGJlICpjYWxsZWQqIGluc2lkZSBhIFJlYWN0IGNvbXBvbmVudCAoUmVhY3QgaG9va3MgYXJlIG1lYW50IHRvIHRyaWdnZXIgYSBjb21wb25lbnQgcmUtcmVuZGVyKS5cclxuVG8gYWNjZXNzIHRoZSBzdG9yZSBvdXRzaWRlIGEgY29tcG9uZW50LCBjYWxsIG15U3RvcmVIb29rLmdldFN0YXRlKCkuIEZyb20gdGhlcmUsIHlvdSBjYW4gcmVhZFxyXG50aGUgc3RvcmUncyBwcm9wZXJ0aWVzIGFuZCBjYWxsIHRoZSBzdG9yZSdzIGFjdGlvbnMuXHJcblxyXG4qL1xyXG4vLyBjb25zdCBjcmVhdGVBbGxTdHVkZW50c1N0b3JlID0gZnVuY3Rpb24oc2V0KXsgLy9TdG9yZSBpbml0aWFsaXplclxyXG4vLyAgIC8qWnVzdGFuZCBwYXNzZXMgYSBcInNldFwiIGZ1bmN0aW9uIGludG8gaGVyZS4gV2UgY2FsbCBcInNldFwiXHJcbi8vICAgdG8gdXBkYXRlIGFueSBwcm9wZXJ0aWVzIGluIHRoZSBzdG9yZS4gV2hlbiB3ZSBjYWxsIFwic2V0XCIsIHdlIHBhc3MgXCJzZXRcIlxyXG4vLyAgIGEgZnVuY3Rpb24gd2hpY2ggcmV0dXJucyBhIFwicGFydGlhbCBzdGF0ZVwiLCBhbiBvYmplY3QgY29udGFpbmluZyBhbnkgb2YgdGhlIHByb3BlcnRpZXMgb2YgdGhlIHN0b3JlXHJcbi8vICAgd2Ugd2FudCB0byBjaGFuZ2UuXHJcbi8vICAgV2UgY2FuIG9wdGlvbmFsbHkgbWFrZSB0aGF0IGZ1bmN0aW9uIHRha2UgdGhlIHByZXZpb3VzIHN0YXRlIGFzIGEgcGFyYW1ldGVyLlxyXG4vLyAgICovXHJcbi8vICAgY29uc3QgZ2V0QWxsU3R1ZGVudHNGcm9tTG9jYWxTdG9yYWdlID0gZnVuY3Rpb24oKXtcclxuLy8gICAgIC8qVGhpcyBmdW5jdGlvbiBkZWZpbmVzIHRoZSBsb2dpYyBmb3IgdGhlIGluaXRBbGxTdHVkZW50cyBhY3Rpb24gKHNlZSBiZWxvdykuXHJcbi8vICAgICBUaGlzIGZ1bmN0aW9uIGRvZXNuJ3QgcmVxdWlyZSB0aGUgcHJldmlvdXMgc3RhdGUgYXMgYSBwYXJhbWV0ZXIuXHJcbi8vICAgICBUaGlzIGZ1bmN0aW9uIHJldHVybnMgYSBcInBhcnRpYWwgc3RhdGVcIiB3aGljaCB1cGRhdGVzIHRoZSBcImFsbFN0dWRlbnRzXCIgcHJvcGVydHkgb2YgdGhlIHN0b3JlLlxyXG4vLyAgICAgKi9cclxuLy8gICAgIGxldCBhbGxTdHVkZW50c0luTG9jYWxTdG9yYWdlID0gbG9jYWxTdG9yYWdlLmdldEl0ZW0oXCJhbGxTdHVkZW50c1wiKVxyXG4vLyAgICAgaWYoYWxsU3R1ZGVudHNJbkxvY2FsU3RvcmFnZSAhPT0gbnVsbCl7XHJcbi8vICAgICAgIC8vY29uc29sZS5sb2coXCJGb3VuZCBhbGxTdHVkZW50cyBpbiBsb2NhbCBzdG9yYWdlLlwiKVxyXG4vLyAgICAgICByZXR1cm4geyBhbGxTdHVkZW50czogSlNPTi5wYXJzZShhbGxTdHVkZW50c0luTG9jYWxTdG9yYWdlKSB9XHJcbi8vICAgICB9IGVsc2Uge1xyXG4vLyAgICAgICAvL2NvbnNvbGUubG9nKFwiRGlkbid0IGZpbmQgYWxsU3R1ZGVudHMgaW4gbG9jYWwgc3RvcmFnZS5cIilcclxuLy8gICAgICAgcmV0dXJuIHsgYWxsU3R1ZGVudHM6IHt9IH1cclxuLy8gICAgIH1cclxuLy8gICB9XHJcbiAgXHJcbi8vICAgY29uc3Qgc2V0QWxsU3R1ZGVudHNUb1ZhbHVlID0gZnVuY3Rpb24oIG5ld1ZhbHVlICl7XHJcbi8vICAgICByZXR1cm4geyBhbGxTdHVkZW50czogbmV3VmFsdWUgfVxyXG4vLyAgIH1cclxuICBcclxuLy8gICByZXR1cm4ge1xyXG4vLyAgICAgYWxsU3R1ZGVudHM6IHt9LFxyXG4vLyAgICAgaW5pdEFsbFN0dWRlbnRzOiAoKT0+IHsgc2V0KGdldEFsbFN0dWRlbnRzRnJvbUxvY2FsU3RvcmFnZSkgfSwgLy9BY3Rpb25cclxuLy8gICAgIC8qXHJcbi8vICAgICBUaGUgaW5pdEFsbFN0dWRlbnRzKCkgYWN0aW9uIGlzIGNhbGxlZCBpbiBIb21lUGFnZSgpLCB3aGVuIHRoZSBIb21lUGFnZSBjb21wb25lbnRcclxuLy8gICAgIGlzIG1vdW50ZWQgZm9yIHRoZSBmaXJzdCB0aW1lLiBUbyBkbyB0aGlzLCB3ZSB1c2UgSG9tZVBhZ2UncyB1c2VFZmZlY3QoKSBob29rLCBwYXNzIGluIGEgZnVuY3Rpb25cclxuLy8gICAgIHRoYXQgY2FsbHMgaW5pdEFsbFN0dWRlbnRzKCksIGFuZCBhbHNvIHBhc3MgaW4gYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBbXSwgd2hpY2ggdGVsbHMgUmVhY3QgdG8gb25seVxyXG4vLyAgICAgcnVuIHRoYXQgZnVuY3Rpb24gb25jZSB3aGVuIHRoZSBjb21wb25lbnQgaXMgbW91bnRlZC5cclxuLy8gICAgICovXHJcbi8vICAgIHNldEFsbFN0dWRlbnRzOiAobmV3VmFsdWUpID0+IHsgc2V0KCBzZXRBbGxTdHVkZW50c1RvVmFsdWUobmV3VmFsdWUpICkgfSxcclxuLy8gICB9XHJcbi8vIH1cclxuXHJcbi8vIGNvbnN0IHVzZUFsbFN0dWRlbnRzU3RvcmUgPSBjcmVhdGUoY3JlYXRlQWxsU3R1ZGVudHNTdG9yZSkgLy9SZXR1cm5zIGEgc3RvcmUgaG9va1xyXG5cclxuLy9GaWxsZXIgZGF0YSBmb3IgZGVidWdnaW5nXHJcbi8vIGNvbnN0IGZpbGxlclN0dWRlbnREYXRhID0ge1xyXG4vLyAgIFwiMVwiOiB7IC8vaWQgbnVtYmVyIGZvciB0aGUgc3R1ZGVudCAodG8gYXZvaWQgZ2xpdGNoZXMgdyBzYW1lLW5hbWUgc3R1ZGVudHMpXHJcbi8vICAgICBcIm5hbWVcIjogXCJTdHVkZW50IDFcIixcclxuLy8gICAgIFwiY29sb3JcIjogXCJwaW5rXCJcclxuLy8gICB9LFxyXG4vLyAgIFwiMlwiOiB7XHJcbi8vICAgICBcIm5hbWVcIjogXCJTdHVkZW50IDJcIixcclxuLy8gICAgIFwiY29sb3JcIjogXCJwdXJwbGVcIlxyXG4vLyAgIH0sXHJcbi8vICAgXCIzXCI6IHtcclxuLy8gICAgIFwibmFtZVwiOiBcIlN0dWRlbnQgM1wiLFxyXG4vLyAgICAgXCJjb2xvclwiOiBcImJsdWVcIlxyXG4vLyAgIH1cclxuLy8gfVxyXG5cclxuXHJcbi8vIGNvbnN0IGZpbGxlclN0dWRlbnREYXRhID0ge31cclxuLy8gaWYodHJ1ZSl7XHJcbi8vICAgbGV0IGNvbG9yQ3ljbGUgPSBcInJlZCBvcmFuZ2UgeWVsbG93IGdyZWVuIGN5YW4gYmx1ZSBwdXJwbGUgcGlua1wiLnNwbGl0KFwiIFwiKVxyXG4vLyAgIGZvcihsZXQgaSA9IDE7IGkgPCAxMDA7IGkgKyspe1xyXG4vLyAgICAgZmlsbGVyU3R1ZGVudERhdGFbaV0gPSB7XHJcbi8vICAgICAgIFwibmFtZVwiOiBcIlN0dWRlbnQgXCIgKyBpLFxyXG4vLyAgICAgICBcImNvbG9yXCI6IGNvbG9yQ3ljbGVbIChpLTEpICUgY29sb3JDeWNsZS5sZW5ndGhdXHJcbi8vICAgICB9XHJcbi8vICAgfVxyXG4vLyB9XHJcbi8vIHVzZUFsbFN0dWRlbnRzU3RvcmUuZ2V0U3RhdGUoKS5zZXRBbGxTdHVkZW50cyhmaWxsZXJTdHVkZW50RGF0YSlcclxuXHJcbmNvbnN0IHVzZVNlc3Npb25TdGF0ZVN0b3JlID0gY3JlYXRlKCAoc2V0KT0+ICh7XHJcbiAgLy8gb3BlblN0dWRlbnRzOiB7XHJcbiAgLy8gICBcIjJcIjoge1xyXG4gIC8vICAgICBcIm9wZW5Xb3Jrc2hlZXRzXCI6IFtdLFxyXG4gIC8vICAgICBcInBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbFwiOiAwXHJcbiAgLy8gICB9LFxyXG4gIC8vICAgXCIxXCI6IHtcclxuICAvLyAgICAgXCJvcGVuV29ya3NoZWV0c1wiOiBbXSxcclxuICAvLyAgICAgXCJwb3NpdGlvbkluV29ya3NoZWV0U2VsZWN0aW9uUGFuZWxcIjogMVxyXG4gIC8vICAgfVxyXG4gIC8vIH0sXHJcbiAgLy8gaGlnaGVzdFBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbDogMSxcclxuICAvLyBkZWxldGVPcGVuU3R1ZGVudDogKHN0dWRlbnRJRE51bWJlcik9PntcclxuICAvLyAgIGxldCBuZXdPcGVuU3R1ZGVudHMgPSB7Li4udXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5vcGVuU3R1ZGVudHN9XHJcbiAgLy8gICBkZWxldGUgbmV3T3BlblN0dWRlbnRzW3N0dWRlbnRJRE51bWJlcl1cclxuICAvLyAgIHNldCggKCk9Pih7IG9wZW5TdHVkZW50czogbmV3T3BlblN0dWRlbnRzIH0pIClcclxuICAvLyB9LFxyXG4gIC8vIGFkZE9wZW5TdHVkZW50VG9Cb3R0b206IChzdHVkZW50SUROdW1iZXIpPT57XHJcbiAgLy8gICBsZXQgbmV3T3BlblN0dWRlbnRzID0gey4uLnVzZVNlc3Npb25TdGF0ZVN0b3JlLmdldFN0YXRlKCkub3BlblN0dWRlbnRzfVxyXG4gIC8vICAgbGV0IGhpZ2hlc3RQb3NpdGlvbkluV29ya3NoZWV0U2VsZWN0aW9uUGFuZWwgPSB1c2VTZXNzaW9uU3RhdGVTdG9yZS5nZXRTdGF0ZSgpLmhpZ2hlc3RQb3NpdGlvbkluV29ya3NoZWV0U2VsZWN0aW9uUGFuZWxcclxuICAvLyAgIGxldCBuZXdPcGVuU3R1ZGVudCA9IHtcclxuICAvLyAgICAgXCJvcGVuV29ya3NoZWV0c1wiOiBbXSxcclxuICAvLyAgICAgXCJwb3NpdGlvbkluV29ya3NoZWV0U2VsZWN0aW9uUGFuZWxcIjogaGlnaGVzdFBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbCArIDFcclxuICAvLyAgIH1cclxuICAvLyAgIG5ld09wZW5TdHVkZW50c1tzdHVkZW50SUROdW1iZXJdID0gbmV3T3BlblN0dWRlbnRcclxuICAvLyAgIHNldCggKCk9Pih7IG9wZW5TdHVkZW50czogbmV3T3BlblN0dWRlbnRzIH0pIClcclxuICAvLyAgIHNldCggKCkgPT4gKHsgaGlnaGVzdFBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbDogaGlnaGVzdFBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbCArIDEgfSkgKVxyXG4gIC8vIH1cclxuICAvLyBvcGVuU3R1ZGVudHM6IFtcclxuICAvLyAgIHtcIm9wZW5Xb3Jrc2hlZXRzXCI6IFtdLCBcInN0dWRlbnRJRE51bWJlclwiOiBcIjFcIn0sXHJcbiAgLy8gICB7XCJvcGVuV29ya3NoZWV0c1wiOiBbXSwgXCJzdHVkZW50SUROdW1iZXJcIjogXCIyXCJ9LFxyXG4gIC8vICAge1wib3BlbldvcmtzaGVldHNcIjogW10sIFwic3R1ZGVudElETnVtYmVyXCI6IFwiM1wifSxcclxuICAvLyAgIHtcIm9wZW5Xb3Jrc2hlZXRzXCI6IFtdLCBcInN0dWRlbnRJRE51bWJlclwiOiBcIm90aGVyXCJ9XHJcbiAgLy8gXSxcclxuICBcclxuICBvcGVuU3R1ZGVudHM6IFtcclxuICAgIHtvcGVuV29ya3NoZWV0czogW10sIHR5cGU6IFwic3R1ZGVudFwiLCBuYW1lOiBcIlN0dWRlbnQgMVwiLCBjb2xvcjogXCJyZWRcIn0sXHJcbiAgICB7b3BlbldvcmtzaGVldHM6IFtdLCB0eXBlOiBcInN0dWRlbnRcIiwgbmFtZTogXCJTdHVkZW50IDJcIiwgY29sb3I6IFwib3JhbmdlXCJ9LFxyXG4gICAge29wZW5Xb3Jrc2hlZXRzOiBbXSwgdHlwZTogXCJzdHVkZW50XCIsIG5hbWU6IFwiU3R1ZGVudCAzXCIsIGNvbG9yOiBcInllbGxvd1wifSxcclxuICAgIHtvcGVuV29ya3NoZWV0czogW10sIHR5cGU6IFwib3RoZXJcIiwgbmFtZTogXCJPdGhlclwiLCBjb2xvcjogXCJub25lXCJ9LFxyXG4gIF0sXHJcbiAgbnVtYmVySW5OYW1lT2ZMYXN0U3R1ZGVudEFkZGVkOiAzLFxyXG4gIHNldE9wZW5TdHVkZW50czogKG5ld1ZhbHVlKT0+e1xyXG4gICAgc2V0KCAoKT0+KHsgb3BlblN0dWRlbnRzOiBuZXdWYWx1ZSB9KSApO1xyXG4gICAgdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5zYXZlVG9Mb2NhbFN0b3JhZ2UoKVxyXG4gIH0sXHJcbiAgZGVsZXRlT3BlblN0dWRlbnQ6IChpbmRleEluT3BlblN0dWRlbnRzKT0+e1xyXG4gICAgLypcclxuICAgIFdoZW4gZGVsZXRpbmcgYSBzdHVkZW50LCB3ZSBuZWVkIHRvIHVwZGF0ZSB0aGUgb3BlblN0dWRlbnRJbmRleCBvZiB0aGUgY3VycmVudFdvcmtzaGVldFxyXG4gICAgYmVjYXVzZSB0aGUgb3BlblN0dWRlbnRzIGFycmF5IHdpbGwgYmUgc2hvcnRlciBhZnRlciB0aGUgc3R1ZGVudCBpcyBkZWxldGVkLlxyXG4gICAgVG8gZG8gdGhpcywgd2UnbGwgc3VidHJhY3Qgb25lIGZyb20gdGhlIGluZGV4IG9mIHRoZSBjdXJyZW50V29ya3NoZWV0Lm9wZW5TdHVkZW50SW5kZXggaWZcclxuICAgIGl0IGlzIGdyZWF0ZXIgdGhhbiB0aGUgaW5kZXggb2YgdGhlIHN0dWRlbnQgYmVpbmcgZGVsZXRlZC5cclxuICAgICovXHJcbiAgICBjb25zdCBpbmRleE9mU3R1ZGVudFdpdGhDdXJyZW50V29ya3NoZWV0ID0gdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50V29ya3NoZWV0Lm9wZW5TdHVkZW50SW5kZXhcclxuICAgIGlmKGluZGV4T2ZTdHVkZW50V2l0aEN1cnJlbnRXb3Jrc2hlZXQgPT0gaW5kZXhJbk9wZW5TdHVkZW50cyl7XHJcbiAgICAgIC8vSWYgdGhlIHN0dWRlbnQgd2UncmUgZGVsZXRpbmcgaXMgdGhlIHN0dWRlbnQgd2l0aCB0aGUgY3VycmVudGx5IG9wZW4gd29ya3NoZWV0LCBzZXQgdG8gbnVsbFxyXG4gICAgICB1c2VTZXNzaW9uU3RhdGVTdG9yZS5nZXRTdGF0ZSgpLnNldEN1cnJlbnRXb3Jrc2hlZXQobnVsbCwgbnVsbClcclxuICAgIH1cclxuICAgIGlmKGluZGV4T2ZTdHVkZW50V2l0aEN1cnJlbnRXb3Jrc2hlZXQgIT09IG51bGwgJiYgaW5kZXhPZlN0dWRlbnRXaXRoQ3VycmVudFdvcmtzaGVldCA+IGluZGV4SW5PcGVuU3R1ZGVudHMpIHtcclxuICAgICAgLy8gSWYgdGhlIGN1cnJlbnRXb3Jrc2hlZXQncyBvcGVuU3R1ZGVudEluZGV4IGlzIGdyZWF0ZXIgdGhhbiB0aGUgaW5kZXggb2YgdGhlIHN0dWRlbnQgYmVpbmcgZGVsZXRlZCxcclxuICAgICAgLy8gZGVjcmVtZW50IGl0IGJ5IDEgdG8gbWFpbnRhaW4gdGhlIGNvcnJlY3QgaW5kZXggaW4gdGhlIG9wZW5TdHVkZW50cyBhcnJheS5cclxuICAgICAgY29uc3QgbmV3Q3VycmVudFdvcmtzaGVldCA9IHsgLi4udXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5jdXJyZW50V29ya3NoZWV0IH1cclxuICAgICAgbmV3Q3VycmVudFdvcmtzaGVldC5vcGVuU3R1ZGVudEluZGV4ID0gaW5kZXhPZlN0dWRlbnRXaXRoQ3VycmVudFdvcmtzaGVldCAtIDFcclxuICAgICAgc2V0KCAoKT0+KHsgY3VycmVudFdvcmtzaGVldDogbmV3Q3VycmVudFdvcmtzaGVldCB9KSApXHJcbiAgICB9XHJcbiAgICBcclxuICAgIFxyXG4gICAgLy8gRGVsZXRlIHRoZSBzdHVkZW50IGF0IGluZGV4SW5PcGVuU3R1ZGVudHMgZnJvbSBvcGVuU3R1ZGVudHMgYXJyYXlcclxuICAgIGxldCBuZXdPcGVuU3R1ZGVudHMgPSBbLi4udXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5vcGVuU3R1ZGVudHNdO1xyXG4gICAgbmV3T3BlblN0dWRlbnRzLnNwbGljZShpbmRleEluT3BlblN0dWRlbnRzLCAxKTsgLy9SZW1vdmUgdGhlIHN0dWRlbnQgYXQgdGhlIHNwZWNpZmllZCBpbmRleFxyXG4gICAgc2V0KCAoKT0+KHsgb3BlblN0dWRlbnRzOiBuZXdPcGVuU3R1ZGVudHMgfSkgKTtcclxuICAgIHVzZVNlc3Npb25TdGF0ZVN0b3JlLmdldFN0YXRlKCkuc2F2ZVRvTG9jYWxTdG9yYWdlKClcclxuICAgIFxyXG4gIH0sXHJcbiAgYWRkT3BlblN0dWRlbnRUb0JvdHRvbTogKHN0dWRlbnROYW1lLCBjb2xvcik9PntcclxuICAgIGNvbnN0IG5ld1N0dWRlbnREYXRhID0ge29wZW5Xb3Jrc2hlZXRzOiBbXSwgdHlwZTogXCJzdHVkZW50XCIsIG5hbWU6IHN0dWRlbnROYW1lLCBjb2xvcjogY29sb3J9XHJcbiAgICAvL0FkZCBuZXdTdHVkZW50RGF0YSBhcyBzZWNvbmQgdG8gbGFzdCBzdHVkZW50IGluIG9wZW5TdHVkZW50c1xyXG4gICAgbGV0IG5ld09wZW5TdHVkZW50cyA9IFsuLi51c2VTZXNzaW9uU3RhdGVTdG9yZS5nZXRTdGF0ZSgpLm9wZW5TdHVkZW50c107XHJcbiAgICBuZXdPcGVuU3R1ZGVudHMuc3BsaWNlKG5ld09wZW5TdHVkZW50cy5sZW5ndGggLSAxLCAwLCBuZXdTdHVkZW50RGF0YSk7XHJcbiAgICBzZXQoICgpPT4oeyBvcGVuU3R1ZGVudHM6IG5ld09wZW5TdHVkZW50cyB9KSApXHJcbiAgICBcclxuICAgIHVzZVNlc3Npb25TdGF0ZVN0b3JlLmdldFN0YXRlKCkuc2F2ZVRvTG9jYWxTdG9yYWdlKClcclxuICB9LFxyXG4gIFxyXG4gIGN1cnJlbnRQYWdlOiBcIldvcmtzaGVldFZpZXdlclwiLFxyXG4gIHNldEN1cnJlbnRQYWdlOiAobmV3VmFsdWUpPT57XHJcbiAgICBzZXQoICgpPT4oeyBjdXJyZW50UGFnZTogbmV3VmFsdWUgfSkgKVxyXG4gICAgdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5zYXZlVG9Mb2NhbFN0b3JhZ2UoKVxyXG4gIH0sXHJcbiAgY3VycmVudFdvcmtzaGVldDogeyBvcGVuU3R1ZGVudEluZGV4OiBudWxsLCB3b3Jrc2hlZXRJbmRleDogbnVsbCB9LFxyXG4gIHNldEN1cnJlbnRXb3Jrc2hlZXQ6IChvcGVuU3R1ZGVudEluZGV4LCB3b3Jrc2hlZXRJbmRleCk9PntcclxuICAgIHNldCggKCk9Pih7IGN1cnJlbnRXb3Jrc2hlZXQ6IHsgb3BlblN0dWRlbnRJbmRleDogb3BlblN0dWRlbnRJbmRleCwgd29ya3NoZWV0SW5kZXg6IHdvcmtzaGVldEluZGV4IH0gfSkgKVxyXG4gICAgdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5zYXZlVG9Mb2NhbFN0b3JhZ2UoKVxyXG4gIH0sXHJcbiAgZ2V0Q3VycmVudFdvcmtzaGVldElEOiAoKT0+e1xyXG4gICAgY29uc3QgeyBvcGVuU3R1ZGVudHMsIGN1cnJlbnRXb3Jrc2hlZXQgfSA9IHVzZVNlc3Npb25TdGF0ZVN0b3JlLmdldFN0YXRlKClcclxuICAgIGlmKGN1cnJlbnRXb3Jrc2hlZXQub3BlblN0dWRlbnRJbmRleCA9PT0gbnVsbCB8fCBjdXJyZW50V29ya3NoZWV0LndvcmtzaGVldEluZGV4ID09PSBudWxsKSByZXR1cm4gbnVsbFxyXG4gICAgXHJcbiAgICByZXR1cm4gb3BlblN0dWRlbnRzW2N1cnJlbnRXb3Jrc2hlZXQub3BlblN0dWRlbnRJbmRleF0ub3BlbldvcmtzaGVldHNbY3VycmVudFdvcmtzaGVldC53b3Jrc2hlZXRJbmRleF0uaWRcclxuICB9LFxyXG4gIHVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQ6IGZhbHNlLFxyXG4gIHNldFVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQ6IChuZXdWYWx1ZSk9PntcclxuICAgIHNldCggKCk9Pih7IHVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQ6IG5ld1ZhbHVlIH0pIClcclxuICB9LFxyXG4gIHVzZXJDYW5DbGlja0FueXdoZXJlVG9EaXNhYmxlTW92aW5nQ3VycmVudFdvcmtzaGVldDogZmFsc2UsXHJcbiAgc2V0VXNlckNhbkNsaWNrQW55d2hlcmVUb0Rpc2FibGVNb3ZpbmdDdXJyZW50V29ya3NoZWV0OiAobmV3VmFsdWUpPT57IHNldCggKCk9Pih7IHVzZXJDYW5DbGlja0FueXdoZXJlVG9EaXNhYmxlTW92aW5nQ3VycmVudFdvcmtzaGVldDogbmV3VmFsdWUgfSkgKSB9LFxyXG4gIGN1cnJlbnRQYWdlT2ZXb3Jrc2hlZXQ6IDAsIC8vVmFsdWUgb2YgdGhlIHBhZ2Ugb24gdGhlIGxlZnRcclxuICBzZXRDdXJyZW50UGFnZU9mV29ya3NoZWV0OiAobmV3VmFsdWUpPT57IFxyXG4gICAgc2V0KCAoKT0+KHsgY3VycmVudFBhZ2VPZldvcmtzaGVldDogbmV3VmFsdWUgfSkgKVxyXG4gICAgY29uc3QgeyBvcGVuU3R1ZGVudHMsIGN1cnJlbnRXb3Jrc2hlZXQgfSA9IHVzZVNlc3Npb25TdGF0ZVN0b3JlLmdldFN0YXRlKClcclxuICAgIGlmIChjdXJyZW50V29ya3NoZWV0Lm9wZW5TdHVkZW50SW5kZXggIT09IG51bGwgJiYgY3VycmVudFdvcmtzaGVldC53b3Jrc2hlZXRJbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICBvcGVuU3R1ZGVudHNbY3VycmVudFdvcmtzaGVldC5vcGVuU3R1ZGVudEluZGV4XS5vcGVuV29ya3NoZWV0c1tjdXJyZW50V29ya3NoZWV0LndvcmtzaGVldEluZGV4XS5wYWdlTGVmdE9mZiA9IG5ld1ZhbHVlXHJcbiAgICAgIHNldCh7IG9wZW5TdHVkZW50czogWy4uLm9wZW5TdHVkZW50c10gfSlcclxuICAgIH1cclxuICAgIFxyXG4gICAgdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5zYXZlVG9Mb2NhbFN0b3JhZ2UoKVxyXG4gIH0sXHJcbiAgYWxsb3dBcnJvd0tleXNGb3JQYWdlTmF2aWdhdGlvbjogdHJ1ZSxcclxuICBzZXRBbGxvd0Fycm93S2V5c0ZvclBhZ2VOYXZpZ2F0aW9uOiAobmV3VmFsdWUpPT57IHNldCggKCk9Pih7IGFsbG93QXJyb3dLZXlzRm9yUGFnZU5hdmlnYXRpb246IG5ld1ZhbHVlIH0pICkgfSxcclxuICBcclxuICBzYXZlVG9Mb2NhbFN0b3JhZ2U6ICgpID0+IHtcclxuICAgIGNvbnN0IHNlc3Npb25TdGF0ZSA9IHVzZVNlc3Npb25TdGF0ZVN0b3JlLmdldFN0YXRlKClcclxuICAgIC8vU3RvcmUgb25seSB0aGUgZm9sbG93aW5nIHZhbHVlcyBpbiBsb2NhbCBzdG9yYWdlXHJcbiAgICBjb25zdCBwYXJ0aWFsU2Vzc2lvblN0YXRlID0ge1xyXG4gICAgICBvcGVuU3R1ZGVudHM6IHNlc3Npb25TdGF0ZS5vcGVuU3R1ZGVudHMsXHJcbiAgICAgIGN1cnJlbnRQYWdlOiBzZXNzaW9uU3RhdGUuY3VycmVudFBhZ2UsXHJcbiAgICAgIGN1cnJlbnRXb3Jrc2hlZXQ6IHNlc3Npb25TdGF0ZS5jdXJyZW50V29ya3NoZWV0LFxyXG4gICAgICBjdXJyZW50UGFnZU9mV29ya3NoZWV0OiBzZXNzaW9uU3RhdGUuY3VycmVudFBhZ2VPZldvcmtzaGVldFxyXG4gICAgfVxyXG4gICAgbG9jYWxTdG9yYWdlLnNldEl0ZW0oXCJzZXNzaW9uU3RhdGVcIiwgSlNPTi5zdHJpbmdpZnkocGFydGlhbFNlc3Npb25TdGF0ZSkpXHJcbiAgfSxcclxuICBcclxuICBsb2FkRnJvbUxvY2FsU3RvcmFnZTogKCkgPT4ge1xyXG4gICAgY29uc3Qgc2Vzc2lvblN0YXRlRnJvbUxvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwic2Vzc2lvblN0YXRlXCIpXHJcbiAgICBpZihzZXNzaW9uU3RhdGVGcm9tTG9jYWxTdG9yYWdlICE9PSBudWxsKXtcclxuICAgICAgY29uc29sZS5sb2coXCJsb2FkaW5nIHNlc3Npb25zdGF0ZSBmcm9tIGxvY2FsIHN0b3JhZ2VcIilcclxuICAgICAgY29uc3QgcGFydGlhbFNlc3Npb25TdGF0ZSA9IEpTT04ucGFyc2Uoc2Vzc2lvblN0YXRlRnJvbUxvY2FsU3RvcmFnZSlcclxuICAgICAgc2V0KCAoKT0+KHtcclxuICAgICAgICBvcGVuU3R1ZGVudHM6IHBhcnRpYWxTZXNzaW9uU3RhdGUub3BlblN0dWRlbnRzLFxyXG4gICAgICAgIGN1cnJlbnRQYWdlOiBwYXJ0aWFsU2Vzc2lvblN0YXRlLmN1cnJlbnRQYWdlLFxyXG4gICAgICAgIGN1cnJlbnRXb3Jrc2hlZXQ6IHBhcnRpYWxTZXNzaW9uU3RhdGUuY3VycmVudFdvcmtzaGVldCxcclxuICAgICAgICBjdXJyZW50UGFnZU9mV29ya3NoZWV0OiBwYXJ0aWFsU2Vzc2lvblN0YXRlLmN1cnJlbnRQYWdlT2ZXb3Jrc2hlZXRcclxuICAgICAgfSkgKVxyXG4gICAgfVxyXG4gIH1cclxufSkpXHJcblxyXG5jb25zdCB1c2VVc2VyU2V0dGluZ3NTdG9yZSA9IGNyZWF0ZSggKHNldCk9PiAoe1xyXG4gIC8vc2V0dGluZ3MgZ28gaGVyZVxyXG4gIHBhZ2VWaWV3OiBcImRvdWJsZVwiLCAvL3NpbmdsZSBvciBkb3VibGVcclxuICBzZXRQYWdlVmlldzogKG5ld1ZhbHVlKT0+eyBzZXQoICgpPT4oeyBwYWdlVmlldzogbmV3VmFsdWUgfSkgKSB9LFxyXG4gIG1hZGlzb25Nb2RlOiBmYWxzZSxcclxuICBzZXRNYWRpc29uTW9kZTogKG5ld1ZhbHVlKT0+eyBzZXQoICgpPT4oeyBtYWRpc29uTW9kZTogbmV3VmFsdWUgfSkgKSB9XHJcbn0pKVxyXG5cclxuZXhwb3J0IGZ1bmN0aW9uIGNhbGNVc2VySGFzUGluY2hab29tZWQoKXtcclxuICAvL2NhbGN1bGF0ZXMgd2hldGhlciB0aGUgdXNlciBoYXMgcGluY2ggem9vbWVkIG9uIHRoZSBwYWdlXHJcbiAgcmV0dXJuIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5zY2FsZSAhPT0gMVxyXG59XHJcblxyXG5mdW5jdGlvbiB1cGRhdGVVc2VySGFzUGluY2hab29tZWRPblJlc2l6ZSgpe1xyXG4gIC8vSWYgdGhlIHVzZXIgaGFzIHBpbmNoIHpvb21lZCwgc2V0IHRoZSBzdG9yZSB0byB0cnVlLFxyXG4gIC8vYnV0IG9ubHkgaWYgaXQncyBub3QgYWxyZWFkeSBzZXQgdG8gdHJ1ZS4gT3RoZXJ3aXNlLCBzZXR0aW5nIGl0IHRvIHRydWVcclxuICAvL3dvdWxkIGNhdXNlIHVubmVjZXNzYXJ5IHJlcmVuZGVycyBvZiB0aGUgZW50aXJlIEhvbWVQYWdlIGR1cmluZyBldmVyeSBmcmFtZSBvZiBwaW5jaCB6b29tIGdlc3R1cmUuXHJcbiAgaWYoIGNhbGNVc2VySGFzUGluY2hab29tZWQoKSApe1xyXG4gICAgaWYoIXVzZVVzZXJIYXNQaW5jaFpvb21lZFN0b3JlLmdldFN0YXRlKCkudXNlckhhc1BpbmNoWm9vbWVkKXtcclxuICAgICAgdXNlVXNlckhhc1BpbmNoWm9vbWVkU3RvcmUuZ2V0U3RhdGUoKS5zZXRVc2VySGFzUGluY2hab29tZWQodHJ1ZSlcclxuICAgIH1cclxuICB9XHJcbiAgLy9JZiB0aGUgdXNlciBoYXMgbm90IHBpbmNoIHpvb21lZCwgdGhlIHVzZXJIYXNQaW5jaFpvb21lZCBzdGF0ZSBzaG91bGRuJ3QgYmUgc2V0IHRvIGZhbHNlIHVudGlsIHRvdWNoZW5kLlxyXG4gIC8vT3RoZXJ3aXNlLCB0aGUgdXNlciBjb3VsZCB0cmlnZ2VyIGRyYWcgZXZlbnRzIHdoaWxlIHBpbmNoIHpvb21pbmcgaWYgaXQncyB6b29tZWQgYWxsIHRoZSB3YXkgb3V0LlxyXG59XHJcblxyXG5jb25zdCB3b3Jrc2hlZXRzID0ge31cclxuXHJcbmZ1bmN0aW9uIEhvbWVQYWdlKCkge1xyXG4gIGNvbnN0IHsgdXNlckhhc1BpbmNoWm9vbWVkIH0gPSB1c2VVc2VySGFzUGluY2hab29tZWRTdG9yZSgpXHJcbiAgY29uc3QgeyBwYWdlVmlldyB9ID0gdXNlVXNlclNldHRpbmdzU3RvcmUoKVxyXG4gIC8vVGhlIGZ1bmN0aW9uIGluIHRoaXMgdXNlRWZmZWN0IHdpbGwgcnVuIGV2ZXJ5IHRpbWUgSG9tZVBhZ2UgaXMgcmVyZW5kZXJlZCxcclxuICAvL3doaWNoIHdpbGwgaGFwcGVuIGV2ZXJ5IHRpbWUgdXNlckhhc1BpbmNoWm9vbWVkIGNoYW5nZXMsIHdoaWNoIHNob3VsZCBiZVxyXG4gIC8vYXQgdGhlIHN0YXJ0IGFuZCBlbmQgb2YgcGluY2ggem9vbSBnZXN0dXJlcywgYnV0IG5vdCBpbiBiZXR3ZWVuLlxyXG4gIHVzZUVmZmVjdCggKCk9PntcclxuICAgIC8vVGhlc2UgZXZlbnQgbGlzdGVuZXJzIGdldCBhZGRlZCBldmVyeSB0aW1lIHRoZSBjb21wb25lbnQgaXMgcmVyZW5kZXJlZC5cclxuICAgIC8vVG8gcHJldmVudCBldmVudCBsaXN0ZW5lcnMgZnJvbSBhY2N1bXVsYXRpbmcsIHRoZXkgZ2V0IHJlbW92ZWQgd2hlbiB0aGUgY29tcG9uZW50IHVubW91bnRzXHJcbiAgICAvL3ZpYSB0aGUgY2xlYW51cCBmdW5jdGlvbiB0aGF0IGlzIHJldHVybmVkIGJlbG93LlxyXG4gICAgd2luZG93LnZpc3VhbFZpZXdwb3J0LmFkZEV2ZW50TGlzdGVuZXIoXCJyZXNpemVcIiwgdXBkYXRlVXNlckhhc1BpbmNoWm9vbWVkT25SZXNpemUpXHJcbiAgICBkb2N1bWVudC5hZGRFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Eb2N1bWVudFRvdWNoRW5kT3JNb3VzZVVwKVxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcIm1vdXNldXBcIiwgb25Eb2N1bWVudFRvdWNoRW5kT3JNb3VzZVVwKVxyXG4gICAgdXBkYXRlVXNlckhhc1BpbmNoWm9vbWVkT25SZXNpemUoKVxyXG4gICAgXHJcbiAgICBpZih3aW5kb3cubG9jYXRpb24uaHJlZi5pbmNsdWRlcyhcIj9lcnVkYT10cnVlXCIpKXtcclxuICAgICAgLypcclxuICAgICAgRXJ1ZGEgaXMgYSBtb2R1bGUgZm9yIGFkZGluZyB2aXJ0dWFsIGRldnRvb2xzIHRvIGEgd2VicGFnZSBmb3IgbW9iaWxlIGRlYnVnZ2luZy5cclxuICAgICAgRXJ1ZGEgZXhwZWN0cyB0byBiZSBydW4gaW4tYnJvd3Nlciwgc28gaXQgbmVlZHMgdG8gYmUgaW1wb3J0ZWQgZHluYW1pY2FsbHlcclxuICAgICAgZnJvbSB3aXRoaW4gYSBjb21wb25lbnQgbGlrZSBIb21lUGFnZSB3aXRoIHVzZUVmZmVjdC4gSXQncyBub3QgZW5vdWdoIHRvXHJcbiAgICAgIGp1c3QgaW1wb3J0IGl0IGF0IHRoZSB0b3Agb2YgYSBmaWxlIHRoYXQgc2F5cyAndXNlIGNsaWVudCcuXHJcbiAgICAgIFRoZSByZWFzb24gdGhhdCB3ZSdyZSBpbXBvcnRpbmcgdGhpcyBkaWZmZXJlbnRseSBmcm9tIGhvdyBFcnVkYSByZWNvbW1lbmRzXHJcbiAgICAgIGluIGRvY3MgaXMgYmVjYXVzZSBFcnVkYSBkb2Vzbid0IG5lY2Vzc2FyaWx5IGV4cGVjdCB0byBiZSB1c2VkIGluIGFcclxuICAgICAgUmVhY3QvTmV4dGpzIGFwcC5cclxuICAgICAgXHJcbiAgICAgIEZvciBBbmRyb2lkLCB3ZSBjYW4gdXNlIGNocm9tZTovL2luc3BlY3QvI2RldmljZXMgdG8gZG8gcmVtb3RlIGRlYnVnZ2luZyBmb3JcclxuICAgICAgQ2hyb21lLCBidXQgbm90IGZvciBvdGhlciBicm93c2Vycy5cclxuICAgICAgaHR0cHM6Ly9kZXZlbG9wZXIuY2hyb21lLmNvbS9kb2NzL2RldnRvb2xzL3JlbW90ZS1kZWJ1Z2dpbmdcclxuICAgICAgXHJcbiAgICAgIEhvd2V2ZXIsIHRoZSBwb3J0LWZvcndhcmRpbmcgZmVhdHVyZSBvZiBjaHJvbWU6Ly9pbnNwZWN0LyNkZXZpY2VzIGNhbiBiZVxyXG4gICAgICB1c2VkIG9uIGFueSB3ZWIgYnJvd3NlciBvbiB0aGUgQW5kcm9pZCBkZXZpY2UsIHdoaWNoIGFsbG93cyB1cyB0byBydW4gdGhlXHJcbiAgICAgIHdlYnBhZ2UgZnJvbSBcIm5wbSBydW4gZGV2XCIgaW5zdGVhZCBvZiBoYXZpbmcgdG8gYnVpbGQgZmlyc3QuXHJcbiAgICAgIFxyXG4gICAgICBeIEl0IHNlZW1zIGxpa2UgdGhpcyBvZnRlbiByZXF1aXJlcyBvcGVuaW5nIHRoZSBwYWdlIGluIENocm9tZSBmaXJzdCBiZWZvcmVcclxuICAgICAgdGhlbiBvcGVuaW5nIHRoZSBwYWdlIGluIHRoZSBvdGhlciBicm93c2VyIGZvciBzb21lIHJlYXNvbi5cclxuICAgICAgKi9cclxuICAgICAgaW1wb3J0KFwiZXJ1ZGFcIikudGhlbiAoIChtb2R1bGUpID0+IHsgbW9kdWxlLmRlZmF1bHQuaW5pdCgpIH0pXHJcbiAgICB9XHJcbiAgICBcclxuICAgIC8vIHdpbmRvdy5lcnVkYSA9IGVydWRhXHJcbiAgICByZXR1cm4gKCk9PiB7XHJcbiAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZVVzZXJIYXNQaW5jaFpvb21lZE9uUmVzaXplKVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Eb2N1bWVudFRvdWNoRW5kT3JNb3VzZVVwKVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbkRvY3VtZW50VG91Y2hFbmRPck1vdXNlVXApXHJcbiAgICB9XHJcbiAgfSwgW10pXHJcbiAgXHJcbiAgY29uc3QgaG9tZVBhZ2VTdHlsZSA9IHtcclxuICAgIGZvbnRGYW1pbHk6IFwiUm9ib3RvLCBzYW5zLXNlcmlmXCIsXHJcbiAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxyXG4gICAgZm9udFNpemU6IFwiMThweFwiLFxyXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgIG1heFdpZHRoOiAocGFnZVZpZXcgPT0gXCJkb3VibGVcIikgPyBcIjE1MDBweFwiIDogXCIxMDAwcHhcIixcclxuICAgIGNvbG9yOiBjb25zdGFudHMubmVhckJsYWNrQ29sb3IsXHJcbiAgICAvLyB0b3VjaEFjdGlvbjogdXNlckhhc1BpbmNoWm9vbWVkID8gXCJhdXRvXCIgOiBcInBpbmNoLXpvb21cIiwgXHJcbiAgICBtYXJnaW46IFwiMCBhdXRvXCJcclxuICB9XHJcbiAgXHJcbiAgLy8gY29uc3Qgc2Vzc2lvblN0YXRlU3RvcmUgPSB1c2VTZXNzaW9uU3RhdGVTdG9yZSgpXHJcbiAgY29uc3QgY3VycmVudFBhZ2UgPSB1c2VTZXNzaW9uU3RhdGVTdG9yZSggKHN0YXRlKT0+IHN0YXRlLmN1cnJlbnRQYWdlIClcclxuICBcclxuICBpZihjdXJyZW50UGFnZSA9PSBcIldvcmtzaGVldFZpZXdlclwiKXtcclxuICAgIGhvbWVQYWdlU3R5bGUudG91Y2hBY3Rpb24gPSAodXNlckhhc1BpbmNoWm9vbWVkKSA/IFwiYXV0b1wiIDogXCJwaW5jaC16b29tXCIgLy9JZiB0aGUgdXNlciBoYXMgcGluY2ggem9vbWVkLCBhbGxvdyBwYW5uaW5nLiBJZiBub3QsIGRpc2FibGUgcGFubmluZ1xyXG4gIH1cclxuICAvKlxyXG4gIFdoZW4gSG9tZVBhZ2UgbW91bnRzIGZvciB0aGUgZmlyc3QgdGltZSwgaW5pdGlhbGl6ZSBhbGxTdHVkZW50c1N0b3JlIGJ5IGdyYWJiaW5nXHJcbiAgYWxsU3R1ZGVudHMgZnJvbSBsb2NhbFN0b3JhZ2UuIFBhc3MgYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBbXSBpbnRvIHVzZUVmZmVjdCB0byB0ZWxsIFJlYWN0XHJcbiAgdG8gb25seSBydW4gdGhpcyBjb2RlIHRoZSBmaXJzdCB0aW1lIEhvbWVQYWdlIG1vdW50cy5cclxuICAqL1xyXG4gIHVzZUVmZmVjdCggKCk9PntcclxuICAgIC8vdXNlQWxsU3R1ZGVudHNTdG9yZS5nZXRTdGF0ZSgpLmluaXRBbGxTdHVkZW50cygpO1xyXG4gICAgd2luZG93LnVzZVNlc3Npb25TdGF0ZVN0b3JlID0gdXNlU2Vzc2lvblN0YXRlU3RvcmU7XHJcbiAgICB3aW5kb3cudXNlVXNlclNldHRpbmdzU3RvcmUgPSB1c2VVc2VyU2V0dGluZ3NTdG9yZTtcclxuICAgIFxyXG4gICAgLy9PbiBwYWdlIGxvYWQsIHJldHJpZXZlIHdvcmtzaGVldHMgZnJvbSBJbmRleGVkREIgaWYgYW55LiBUaGlzIGZ1bmN0aW9uIGlzIGltcG9ydGVkIGZyb20gU2V0dGluZ3NQYWdlLmpzXHJcbiAgICByZXRyaWV2ZVdvcmtzaGVldHNGcm9tSW5kZXhlZERCKClcclxuICB9LCBbXSlcclxuICAvKlxyXG4gIFRoZSBkZXBlbmRlbmN5IGFycmF5IHdlIHBhc3MgaW50byB1c2VFZmZlY3QgdGVsbHMgUmVhY3Qgd2hpY2ggdmFyaWFibGVzIHRvIGxvb2tcclxuICBmb3IgY2hhbmdlcyBpbi4gV2hlbiBhbnkgb2YgdGhlc2UgdmFyaWFibGVzIGNoYW5nZSwgdGhlIGZ1bmN0aW9uIGluIHVzZUVmZmVjdCgpIGlzXHJcbiAgdHJpZ2dlcmVkLiBFbXB0eSA9IHJ1biBvbmx5IG9uY2UgKG9uIGNvbXBvbmVudCBtb3VudCkuXHJcbiAgKi9cclxuICBjb25zdCBvbkNsaWNrID0gZnVuY3Rpb24oKXtcclxuICAgIGlmKGN1cnJlbnRQYWdlID09IFwiV29ya3NoZWV0Vmlld2VyXCIpe1xyXG4gICAgICBjb25zdCB7IHVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQsIHVzZXJDYW5DbGlja0FueXdoZXJlVG9EaXNhYmxlTW92aW5nQ3VycmVudFdvcmtzaGVldCB9ID0gdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKVxyXG4gICAgICBjb25zdCB7IHVzZXJKdXN0Q2xpY2tlZE1vdmUgfSA9IHVzZVVzZXJKdXN0Q2xpY2tlZE1vdmVTdG9yZS5nZXRTdGF0ZSgpXHJcbiAgICAgIGlmKCF1c2VySnVzdENsaWNrZWRNb3ZlICYmIHVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQgJiYgdXNlckNhbkNsaWNrQW55d2hlcmVUb0Rpc2FibGVNb3ZpbmdDdXJyZW50V29ya3NoZWV0KXtcclxuICAgICAgICBjb25zdCB7IHNldFVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQsIHNldFVzZXJDYW5DbGlja0FueXdoZXJlVG9EaXNhYmxlTW92aW5nQ3VycmVudFdvcmtzaGVldCB9ID0gdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKVxyXG4gICAgICAgIHNldFVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQoZmFsc2UpXHJcbiAgICAgICAgc2V0VXNlckNhbkNsaWNrQW55d2hlcmVUb0Rpc2FibGVNb3ZpbmdDdXJyZW50V29ya3NoZWV0KGZhbHNlKVxyXG4gICAgICB9XHJcbiAgICAgIC8vIGlmKHNlc3Npb25TdGF0ZVN0b3JlLnVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQgJiYgc2Vzc2lvblN0YXRlU3RvcmUudXNlckNhbkNsaWNrQW55d2hlcmVUb0Rpc2FibGVNb3ZpbmdDdXJyZW50V29ya3NoZWV0KXtcclxuICAgICAgLy8gICBjb25zb2xlLmxvZyhcInNldCB0byBmYWxzZVwiKVxyXG4gICAgICAvLyAgIHNlc3Npb25TdGF0ZVN0b3JlLnNldFVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQoZmFsc2UpXHJcbiAgICAgIC8vICAgc2Vzc2lvblN0YXRlU3RvcmUuc2V0VXNlckNhbkNsaWNrQW55d2hlcmVUb0Rpc2FibGVNb3ZpbmdDdXJyZW50V29ya3NoZWV0KGZhbHNlKVxyXG4gICAgICAvLyB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IHN0eWxlPXtob21lUGFnZVN0eWxlfSBvbkNsaWNrPXtvbkNsaWNrfT5cclxuICAgICAge2FsbFBhZ2VzW2N1cnJlbnRQYWdlXX1cclxuICAgIDwvZGl2PlxyXG4gIClcclxufVxyXG5cclxuY29uc3Qgb25Eb2N1bWVudFRvdWNoRW5kT3JNb3VzZVVwID0gZnVuY3Rpb24oKXtcclxuICB1cGRhdGVVc2VySGFzUGluY2hab29tZWRJZkNoYW5nZWQoZmFsc2UpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVVzZXJIYXNQaW5jaFpvb21lZElmQ2hhbmdlZCggY2FsbEFnYWluQm9vbGVhbiApe1xyXG4gIC8vVXBkYXRlIHVzZXJoYXNwaW5jaHpvb21lZCBzdG9yZSwgYnV0IG9ubHkgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxyXG4gIC8vKHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzKVxyXG4gIGNvbnN0IG5ld1VzZXJIYXNQaW5jaFpvb21lZCA9IGNhbGNVc2VySGFzUGluY2hab29tZWQoKVxyXG4gIGNvbnN0IG9sZFVzZXJIYXNQaW5jaFpvb21lZCA9IHVzZVVzZXJIYXNQaW5jaFpvb21lZFN0b3JlLmdldFN0YXRlKCkudXNlckhhc1BpbmNoWm9vbWVkXHJcbiAgaWYob2xkVXNlckhhc1BpbmNoWm9vbWVkICE9PSBuZXdVc2VySGFzUGluY2hab29tZWQpe1xyXG4gICAgdXNlVXNlckhhc1BpbmNoWm9vbWVkU3RvcmUuZ2V0U3RhdGUoKS5zZXRVc2VySGFzUGluY2hab29tZWQobmV3VXNlckhhc1BpbmNoWm9vbWVkKVxyXG4gIH1cclxuICBpZihjYWxsQWdhaW5Cb29sZWFuKSBzZXRUaW1lb3V0KCB1cGRhdGVVc2VySGFzUGluY2hab29tZWRJZkNoYW5nZWQoZmFsc2UpLCAxMDAwIClcclxufVxyXG5cclxuZXhwb3J0IHsgdXNlU2Vzc2lvblN0YXRlU3RvcmUsIHVzZVVzZXJTZXR0aW5nc1N0b3JlLCB3b3Jrc2hlZXRzIH1cclxuZXhwb3J0IGRlZmF1bHQgSG9tZVBhZ2VcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwiY3JlYXRlIiwiV29ya3NoZWV0Vmlld2VyIiwiU2V0dGluZ3NQYWdlIiwicmV0cmlldmVXb3Jrc2hlZXRzRnJvbUluZGV4ZWREQiIsInNldFN0YXR1c01lc3NhZ2VPZldvcmtzaGVldFByb2Nlc3MiLCJ1c2VVc2VySGFzUGluY2hab29tZWRTdG9yZSIsInVzZVVzZXJKdXN0Q2xpY2tlZE1vdmVTdG9yZSIsImNvbnN0YW50cyIsImFsbFBhZ2VzIiwidXNlU2Vzc2lvblN0YXRlU3RvcmUiLCJzZXQiLCJvcGVuU3R1ZGVudHMiLCJvcGVuV29ya3NoZWV0cyIsInR5cGUiLCJuYW1lIiwiY29sb3IiLCJudW1iZXJJbk5hbWVPZkxhc3RTdHVkZW50QWRkZWQiLCJzZXRPcGVuU3R1ZGVudHMiLCJuZXdWYWx1ZSIsImdldFN0YXRlIiwic2F2ZVRvTG9jYWxTdG9yYWdlIiwiZGVsZXRlT3BlblN0dWRlbnQiLCJpbmRleEluT3BlblN0dWRlbnRzIiwiaW5kZXhPZlN0dWRlbnRXaXRoQ3VycmVudFdvcmtzaGVldCIsImN1cnJlbnRXb3Jrc2hlZXQiLCJvcGVuU3R1ZGVudEluZGV4Iiwic2V0Q3VycmVudFdvcmtzaGVldCIsIm5ld0N1cnJlbnRXb3Jrc2hlZXQiLCJuZXdPcGVuU3R1ZGVudHMiLCJzcGxpY2UiLCJhZGRPcGVuU3R1ZGVudFRvQm90dG9tIiwic3R1ZGVudE5hbWUiLCJuZXdTdHVkZW50RGF0YSIsImxlbmd0aCIsImN1cnJlbnRQYWdlIiwic2V0Q3VycmVudFBhZ2UiLCJ3b3Jrc2hlZXRJbmRleCIsImdldEN1cnJlbnRXb3Jrc2hlZXRJRCIsImlkIiwidXNlcklzTW92aW5nQ3VycmVudFdvcmtzaGVldCIsInNldFVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQiLCJ1c2VyQ2FuQ2xpY2tBbnl3aGVyZVRvRGlzYWJsZU1vdmluZ0N1cnJlbnRXb3Jrc2hlZXQiLCJzZXRVc2VyQ2FuQ2xpY2tBbnl3aGVyZVRvRGlzYWJsZU1vdmluZ0N1cnJlbnRXb3Jrc2hlZXQiLCJjdXJyZW50UGFnZU9mV29ya3NoZWV0Iiwic2V0Q3VycmVudFBhZ2VPZldvcmtzaGVldCIsInBhZ2VMZWZ0T2ZmIiwiYWxsb3dBcnJvd0tleXNGb3JQYWdlTmF2aWdhdGlvbiIsInNldEFsbG93QXJyb3dLZXlzRm9yUGFnZU5hdmlnYXRpb24iLCJzZXNzaW9uU3RhdGUiLCJwYXJ0aWFsU2Vzc2lvblN0YXRlIiwibG9jYWxTdG9yYWdlIiwic2V0SXRlbSIsIkpTT04iLCJzdHJpbmdpZnkiLCJsb2FkRnJvbUxvY2FsU3RvcmFnZSIsInNlc3Npb25TdGF0ZUZyb21Mb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiY29uc29sZSIsImxvZyIsInBhcnNlIiwidXNlVXNlclNldHRpbmdzU3RvcmUiLCJwYWdlVmlldyIsInNldFBhZ2VWaWV3IiwibWFkaXNvbk1vZGUiLCJzZXRNYWRpc29uTW9kZSIsImNhbGNVc2VySGFzUGluY2hab29tZWQiLCJ3aW5kb3ciLCJ2aXN1YWxWaWV3cG9ydCIsInNjYWxlIiwidXBkYXRlVXNlckhhc1BpbmNoWm9vbWVkT25SZXNpemUiLCJ1c2VySGFzUGluY2hab29tZWQiLCJzZXRVc2VySGFzUGluY2hab29tZWQiLCJ3b3Jrc2hlZXRzIiwiSG9tZVBhZ2UiLCJhZGRFdmVudExpc3RlbmVyIiwiZG9jdW1lbnQiLCJvbkRvY3VtZW50VG91Y2hFbmRPck1vdXNlVXAiLCJsb2NhdGlvbiIsImhyZWYiLCJpbmNsdWRlcyIsInRoZW4iLCJtb2R1bGUiLCJkZWZhdWx0IiwiaW5pdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJob21lUGFnZVN0eWxlIiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U2l6ZSIsImhlaWdodCIsIndpZHRoIiwibWF4V2lkdGgiLCJuZWFyQmxhY2tDb2xvciIsIm1hcmdpbiIsInN0YXRlIiwidG91Y2hBY3Rpb24iLCJvbkNsaWNrIiwidXNlckp1c3RDbGlja2VkTW92ZSIsImRpdiIsInN0eWxlIiwidXBkYXRlVXNlckhhc1BpbmNoWm9vbWVkSWZDaGFuZ2VkIiwiY2FsbEFnYWluQm9vbGVhbiIsIm5ld1VzZXJIYXNQaW5jaFpvb21lZCIsIm9sZFVzZXJIYXNQaW5jaFpvb21lZCIsInNldFRpbWVvdXQiXSwiaWdub3JlTGlzdCI6W10sInNvdXJjZVJvb3QiOiIifQ==\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.js\n"));

/***/ })

});