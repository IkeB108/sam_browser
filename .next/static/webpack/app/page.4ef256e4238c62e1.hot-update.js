"use strict";
/*
 * ATTENTION: An "eval-source-map" devtool has been used.
 * This devtool is neither made for production nor for readable output files.
 * It uses "eval()" calls to create a separate source file with attached SourceMaps in the browser devtools.
 * If you are trying to read the output file, select a different devtool (https://webpack.js.org/configuration/devtool/)
 * or disable the default devtool with "devtool: false".
 * If you are looking for production-ready output files, see mode: "production" (https://webpack.js.org/configuration/mode/).
 */
self["webpackHotUpdate_N_E"]("app/page",{

/***/ "(app-pages-browser)/./app/page.js":
/*!*********************!*\
  !*** ./app/page.js ***!
  \*********************/
/***/ ((module, __webpack_exports__, __webpack_require__) => {

eval(__webpack_require__.ts("__webpack_require__.r(__webpack_exports__);\n/* harmony export */ __webpack_require__.d(__webpack_exports__, {\n/* harmony export */   calcUserHasPinchZoomed: () => (/* binding */ calcUserHasPinchZoomed),\n/* harmony export */   \"default\": () => (__WEBPACK_DEFAULT_EXPORT__),\n/* harmony export */   useAllStudentsStore: () => (/* binding */ useAllStudentsStore),\n/* harmony export */   useSessionStateStore: () => (/* binding */ useSessionStateStore),\n/* harmony export */   useUserSettingsStore: () => (/* binding */ useUserSettingsStore),\n/* harmony export */   worksheets: () => (/* binding */ worksheets)\n/* harmony export */ });\n/* harmony import */ var react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__ = __webpack_require__(/*! react/jsx-dev-runtime */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/jsx-dev-runtime.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1__ = __webpack_require__(/*! react */ \"(app-pages-browser)/./node_modules/.pnpm/next@15.1.6_react-dom@19.0.0_react@19.0.0__react@19.0.0/node_modules/next/dist/compiled/react/index.js\");\n/* harmony import */ var react__WEBPACK_IMPORTED_MODULE_1___default = /*#__PURE__*/__webpack_require__.n(react__WEBPACK_IMPORTED_MODULE_1__);\n/* harmony import */ var zustand__WEBPACK_IMPORTED_MODULE_6__ = __webpack_require__(/*! zustand */ \"(app-pages-browser)/./node_modules/.pnpm/zustand@5.0.3_react@19.0.0/node_modules/zustand/esm/react.mjs\");\n/* harmony import */ var _components_WorksheetViewer_js__WEBPACK_IMPORTED_MODULE_2__ = __webpack_require__(/*! ./components/WorksheetViewer.js */ \"(app-pages-browser)/./app/components/WorksheetViewer.js\");\n/* harmony import */ var _components_SettingsPage_js__WEBPACK_IMPORTED_MODULE_3__ = __webpack_require__(/*! ./components/SettingsPage.js */ \"(app-pages-browser)/./app/components/SettingsPage.js\");\n/* harmony import */ var _stores_js__WEBPACK_IMPORTED_MODULE_4__ = __webpack_require__(/*! ./stores.js */ \"(app-pages-browser)/./app/stores.js\");\n/* harmony import */ var _constants_js__WEBPACK_IMPORTED_MODULE_5__ = __webpack_require__(/*! ./constants.js */ \"(app-pages-browser)/./app/constants.js\");\n/* __next_internal_client_entry_do_not_use__ calcUserHasPinchZoomed,useAllStudentsStore,useSessionStateStore,useUserSettingsStore,worksheets,default auto */ \nvar _s = $RefreshSig$();\n//     ikeb108.github.io/sam_browser/out\n\n\n\n\n\n\n\n//Keys in allPages use PascalCasing to match the react component names\nconst allPages = {\n    \"WorksheetViewer\": /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_WorksheetViewer_js__WEBPACK_IMPORTED_MODULE_2__[\"default\"], {}, void 0, false, {\n        fileName: \"C:\\\\Users\\\\qwert\\\\Documents\\\\00_Coding\\\\sam_browser\\\\sam_browser\\\\app\\\\page.js\",\n        lineNumber: 13,\n        columnNumber: 22\n    }, undefined),\n    \"SettingsPage\": /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(_components_SettingsPage_js__WEBPACK_IMPORTED_MODULE_3__[\"default\"], {}, void 0, false, {\n        fileName: \"C:\\\\Users\\\\qwert\\\\Documents\\\\00_Coding\\\\sam_browser\\\\sam_browser\\\\app\\\\page.js\",\n        lineNumber: 14,\n        columnNumber: 19\n    }, undefined)\n};\n/*\r\ncreate() is a method from the zustand module for emulating global variables.\r\n(Simpler alternative to useContext, useState, and redux).\r\n\r\ncreate() returns a \"store hook\"--a function which, when called, returns a \"store\".\r\nThe \"store\" is a state container, an object which can have any properties you want.\r\nThese properties could store data or could be updater functions (called \"actions\"), \r\nwhich can change as many or as few data properties as we want.\r\n\r\ncreate() accepts a function (a \"store initializer\"). The store initializer return an object\r\nwhich has all the properties and actions we want our store to have.\r\n\r\n\"Store hooks\" should be declared with const in the global scope.\r\nThey can be attached to the \"window\" object to make them accessible in the browser console.\r\n\"Store hooks\" can only be *called* inside a React component (React hooks are meant to trigger a component re-render).\r\nTo access the store outside a component, call myStoreHook.getState(). From there, you can read\r\nthe store's properties and call the store's actions.\r\n\r\n*/ const createAllStudentsStore = function(set) {\n    /*Zustand passes a \"set\" function into here. We call \"set\"\r\n  to update any properties in the store. When we call \"set\", we pass \"set\"\r\n  a function which returns a \"partial state\", an object containing any of the properties of the store\r\n  we want to change.\r\n  We can optionally make that function take the previous state as a parameter.\r\n  */ const getAllStudentsFromLocalStorage = function() {\n        /*This function defines the logic for the initAllStudents action (see below).\r\n    This function doesn't require the previous state as a parameter.\r\n    This function returns a \"partial state\" which updates the \"allStudents\" property of the store.\r\n    */ let allStudentsInLocalStorage = localStorage.getItem(\"allStudents\");\n        if (allStudentsInLocalStorage !== null) {\n            //console.log(\"Found allStudents in local storage.\")\n            return {\n                allStudents: JSON.parse(allStudentsInLocalStorage)\n            };\n        } else {\n            //console.log(\"Didn't find allStudents in local storage.\")\n            return {\n                allStudents: {}\n            };\n        }\n    };\n    const setAllStudentsToValue = function(newValue) {\n        return {\n            allStudents: newValue\n        };\n    };\n    return {\n        allStudents: {},\n        initAllStudents: ()=>{\n            set(getAllStudentsFromLocalStorage);\n        },\n        /*\r\n    The initAllStudents() action is called in HomePage(), when the HomePage component\r\n    is mounted for the first time. To do this, we use HomePage's useEffect() hook, pass in a function\r\n    that calls initAllStudents(), and also pass in an empty dependency array [], which tells React to only\r\n    run that function once when the component is mounted.\r\n    */ setAllStudents: (newValue)=>{\n            set(setAllStudentsToValue(newValue));\n        }\n    };\n};\nconst useAllStudentsStore = (0,zustand__WEBPACK_IMPORTED_MODULE_6__.create)(createAllStudentsStore) //Returns a store hook\n;\n//Filler data for debugging\nconst fillerStudentData = {\n    \"1\": {\n        \"name\": \"Sidon\",\n        \"color\": \"pink\"\n    },\n    \"2\": {\n        \"name\": \"Yunobo\",\n        \"color\": \"purple\"\n    },\n    \"3\": {\n        \"name\": \"Tulin\",\n        \"color\": \"blue\"\n    }\n};\nuseAllStudentsStore.getState().setAllStudents(fillerStudentData);\nconst useSessionStateStore = (0,zustand__WEBPACK_IMPORTED_MODULE_6__.create)((set)=>({\n        // openStudents: {\n        //   \"2\": {\n        //     \"openWorksheets\": [],\n        //     \"positionInWorksheetSelectionPanel\": 0\n        //   },\n        //   \"1\": {\n        //     \"openWorksheets\": [],\n        //     \"positionInWorksheetSelectionPanel\": 1\n        //   }\n        // },\n        // highestPositionInWorksheetSelectionPanel: 1,\n        // deleteOpenStudent: (studentIDNumber)=>{\n        //   let newOpenStudents = {...useSessionStateStore.getState().openStudents}\n        //   delete newOpenStudents[studentIDNumber]\n        //   set( ()=>({ openStudents: newOpenStudents }) )\n        // },\n        // addOpenStudentToBottom: (studentIDNumber)=>{\n        //   let newOpenStudents = {...useSessionStateStore.getState().openStudents}\n        //   let highestPositionInWorksheetSelectionPanel = useSessionStateStore.getState().highestPositionInWorksheetSelectionPanel\n        //   let newOpenStudent = {\n        //     \"openWorksheets\": [],\n        //     \"positionInWorksheetSelectionPanel\": highestPositionInWorksheetSelectionPanel + 1\n        //   }\n        //   newOpenStudents[studentIDNumber] = newOpenStudent\n        //   set( ()=>({ openStudents: newOpenStudents }) )\n        //   set( () => ({ highestPositionInWorksheetSelectionPanel: highestPositionInWorksheetSelectionPanel + 1 }) )\n        // }\n        openStudents: [\n            {\n                \"openWorksheets\": [\n                    {\n                        id: \"(OLD) 03.01-05 HF (USA) 1-1 WS\",\n                        pageLeftOff: 0\n                    },\n                    {\n                        id: \"(OLD) 03.06-12 TP (USA) 1-1 WS\",\n                        pageLeftOff: 0\n                    }\n                ],\n                \"studentIDNumber\": \"1\"\n            },\n            {\n                \"openWorksheets\": [],\n                \"studentIDNumber\": \"2\"\n            },\n            {\n                \"openWorksheets\": [],\n                \"studentIDNumber\": \"3\"\n            },\n            {\n                \"openWorksheets\": [],\n                \"studentIDNumber\": \"other\"\n            }\n        ],\n        setOpenStudents: (newValue)=>{\n            set(()=>({\n                    openStudents: newValue\n                }));\n        },\n        deleteOpenStudent: (studentIDNumber)=>{\n            /*\r\n    When deleting a student, we need to update the openStudentIndex of the currentWorksheet\r\n    because the openStudents array will be shorter after the student is deleted.\r\n    To do this, we'll grab the student ID number of the student at openStudentIndex\r\n    and then use the student ID number to reset the openStudentIndex after deleting this student.\r\n    This works because there will never be two StudentSessionCards with the same student ID number.\r\n    */ //Get the id number of the student at openStudentIndex\n            const { currentWorksheet, openStudents } = useSessionStateStore.getState();\n            console.log(currentWorksheet, openStudents);\n            const studentIDNumberOfOpenStudent = useSessionStateStore.getState().openStudents[currentWorksheet.openStudentIndex].studentIDNumber;\n            console.log({\n                studentIDNumberOfOpenStudent\n            });\n            let newOpenStudents = useSessionStateStore.getState().openStudents.filter((student)=>student.studentIDNumber !== studentIDNumber);\n            set(()=>({\n                    openStudents: newOpenStudents\n                }));\n            //Use the id number to redefine the openStudentIndex\n            const newOpenStudentIndex = newOpenStudents.findIndex((student)=>student.studentIDNumber === studentIDNumberOfOpenStudent);\n            //If newOpenStudentIndex is -1, that means that we just deleted the student at openStudentIndex\n            //So we need to set openStudentIndex to null\n            if (newOpenStudentIndex === -1) {\n                set(()=>({\n                        currentWorksheet: {\n                            openStudentIndex: null,\n                            worksheetIndex: null\n                        }\n                    }));\n            } else {\n                set(()=>({\n                        currentWorksheet: {\n                            openStudentIndex: newOpenStudentIndex,\n                            worksheetIndex: currentWorksheet.worksheetIndex\n                        }\n                    }));\n            }\n        },\n        addOpenStudentToBottom: (studentIDNumber)=>{\n            let newOpenStudents = useSessionStateStore.getState().openStudents.concat({\n                \"openWorksheets\": [],\n                \"studentIDNumber\": studentIDNumber\n            });\n            set(()=>({\n                    openStudents: newOpenStudents\n                }));\n        },\n        currentPage: \"WorksheetViewer\",\n        setCurrentPage: (newValue)=>{\n            set(()=>({\n                    currentPage: newValue\n                }));\n        },\n        currentWorksheet: {\n            openStudentIndex: null,\n            worksheetIndex: null\n        },\n        setCurrentWorksheet: (openStudentIndex, worksheetIndex)=>{\n            set(()=>({\n                    currentWorksheet: {\n                        openStudentIndex: openStudentIndex,\n                        worksheetIndex: worksheetIndex\n                    }\n                }));\n        },\n        getCurrentWorksheetID: ()=>{\n            const { openStudents, currentWorksheet } = useSessionStateStore.getState();\n            if (currentWorksheet.openStudentIndex === null || currentWorksheet.worksheetIndex === null) return null;\n            return openStudents[currentWorksheet.openStudentIndex].openWorksheets[currentWorksheet.worksheetIndex].id;\n        },\n        userIsMovingCurrentWorksheet: false,\n        setUserIsMovingCurrentWorksheet: (newValue)=>{\n            set(()=>({\n                    userIsMovingCurrentWorksheet: newValue\n                }));\n        },\n        userCanClickAnywhereToDisableMovingCurrentWorksheet: false,\n        setUserCanClickAnywhereToDisableMovingCurrentWorksheet: (newValue)=>{\n            set(()=>({\n                    userCanClickAnywhereToDisableMovingCurrentWorksheet: newValue\n                }));\n        },\n        currentPageOfWorksheet: 0,\n        setCurrentPageOfWorksheet: (newValue)=>{\n            set(()=>({\n                    currentPageOfWorksheet: newValue\n                }));\n            const { openStudents, currentWorksheet } = useSessionStateStore.getState();\n            if (currentWorksheet.openStudentIndex !== null && currentWorksheet.worksheetIndex !== null) {\n                openStudents[currentWorksheet.openStudentIndex].openWorksheets[currentWorksheet.worksheetIndex].pageLeftOff = newValue;\n                set({\n                    openStudents: [\n                        ...openStudents\n                    ]\n                });\n            }\n        },\n        allowArrowKeysForPageNavigation: true,\n        setAllowArrowKeysForPageNavigation: (newValue)=>{\n            set(()=>({\n                    allowArrowKeysForPageNavigation: newValue\n                }));\n        }\n    }));\nconst useUserSettingsStore = (0,zustand__WEBPACK_IMPORTED_MODULE_6__.create)((set)=>({\n        //settings go here\n        pageView: \"double\",\n        setPageView: (newValue)=>{\n            set(()=>({\n                    pageView: newValue\n                }));\n        },\n        madisonMode: false,\n        setMadisonMode: (newValue)=>{\n            set(()=>({\n                    madisonMode: newValue\n                }));\n        }\n    }));\nfunction calcUserHasPinchZoomed() {\n    //calculates whether the user has pinch zoomed on the page\n    return window.visualViewport.scale !== 1;\n}\nfunction updateUserHasPinchZoomedOnResize() {\n    //If the user has pinch zoomed, set the store to true,\n    //but only if it's not already set to true. Otherwise, setting it to true\n    //would cause unnecessary rerenders of the entire HomePage during every frame of pinch zoom gesture.\n    if (calcUserHasPinchZoomed()) {\n        if (!_stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore.getState().userHasPinchZoomed) {\n            _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore.getState().setUserHasPinchZoomed(true);\n        }\n    }\n//If the user has not pinch zoomed, the userHasPinchZoomed state shouldn't be set to false until touchend.\n//Otherwise, the user could trigger drag events while pinch zooming if it's zoomed all the way out.\n}\nconst worksheets = {};\nfunction HomePage() {\n    _s();\n    const { userHasPinchZoomed } = (0,_stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore)();\n    const { pageView } = useUserSettingsStore();\n    //The function in this useEffect will run every time HomePage is rerendered,\n    //which will happen every time userHasPinchZoomed changes, which should be\n    //at the start and end of pinch zoom gestures, but not in between.\n    (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"HomePage.useEffect\": ()=>{\n            //These event listeners get added every time the component is rerendered.\n            //To prevent event listeners from accumulating, they get removed when the component unmounts\n            //via the cleanup function that is returned below.\n            window.visualViewport.addEventListener(\"resize\", updateUserHasPinchZoomedOnResize);\n            document.addEventListener(\"touchend\", onDocumentTouchEndOrMouseUp);\n            document.addEventListener(\"mouseup\", onDocumentTouchEndOrMouseUp);\n            updateUserHasPinchZoomedOnResize();\n            __webpack_require__.e(/*! import() */ \"_app-pages-browser_node_modules_pnpm_eruda_3_4_1_node_modules_eruda_eruda_js\").then(__webpack_require__.t.bind(__webpack_require__, /*! eruda */ \"(app-pages-browser)/./node_modules/.pnpm/eruda@3.4.1/node_modules/eruda/eruda.js\", 23)).then({\n                \"HomePage.useEffect\": (module)=>{\n                    module.default.init();\n                }\n            }[\"HomePage.useEffect\"]);\n            // window.eruda = eruda\n            return ({\n                \"HomePage.useEffect\": ()=>{\n                    window.visualViewport.removeEventListener(\"resize\", updateUserHasPinchZoomedOnResize);\n                    document.removeEventListener(\"touchend\", onDocumentTouchEndOrMouseUp);\n                    document.removeEventListener(\"mouseup\", onDocumentTouchEndOrMouseUp);\n                }\n            })[\"HomePage.useEffect\"];\n        }\n    }[\"HomePage.useEffect\"], []);\n    const homePageStyle = {\n        fontFamily: \"Roboto, sans-serif\",\n        fontWeight: \"normal\",\n        fontSize: \"18px\",\n        height: \"100%\",\n        width: \"100%\",\n        maxWidth: pageView == \"double\" ? \"1500px\" : \"1000px\",\n        color: _constants_js__WEBPACK_IMPORTED_MODULE_5__[\"default\"].nearBlackColor,\n        touchAction: userHasPinchZoomed ? \"auto\" : \"pinch-zoom\",\n        margin: \"0 auto\"\n    };\n    const sessionStateStore = useSessionStateStore();\n    const currentPage = sessionStateStore.currentPage;\n    /*\r\n  When HomePage mounts for the first time, initialize allStudentsStore by grabbing\r\n  allStudents from localStorage. Pass an empty dependency array [] into useEffect to tell React\r\n  to only run this code the first time HomePage mounts.\r\n  */ (0,react__WEBPACK_IMPORTED_MODULE_1__.useEffect)({\n        \"HomePage.useEffect\": ()=>{\n            //useAllStudentsStore.getState().initAllStudents();\n            window.useAllStudentsStore = useAllStudentsStore; //call useAllStudentsStore.getState() when accessing in the dev console.\n            window.useSessionStateStore = useSessionStateStore;\n            window.useUserSettingsStore = useUserSettingsStore;\n            //On page load, retrieve worksheets from IndexedDB if any. This function is imported from SettingsPage.js\n            (0,_components_SettingsPage_js__WEBPACK_IMPORTED_MODULE_3__.retrieveWorksheetsFromIndexedDB)();\n        }\n    }[\"HomePage.useEffect\"], []);\n    /*\r\n  The dependency array we pass into useEffect tells React which variables to look\r\n  for changes in. When any of these variables change, the function in useEffect() is\r\n  triggered. Empty = run only once (on component mount).\r\n  */ const onClick = function() {\n        if (currentPage == \"WorksheetViewer\") {\n            if (sessionStateStore.userIsMovingCurrentWorksheet && sessionStateStore.userCanClickAnywhereToDisableMovingCurrentWorksheet) {\n                sessionStateStore.setUserIsMovingCurrentWorksheet(false);\n                sessionStateStore.setUserCanClickAnywhereToDisableMovingCurrentWorksheet(false);\n            }\n        }\n    };\n    return /*#__PURE__*/ (0,react_jsx_dev_runtime__WEBPACK_IMPORTED_MODULE_0__.jsxDEV)(\"div\", {\n        style: homePageStyle,\n        onClick: onClick,\n        children: allPages[currentPage]\n    }, void 0, false, {\n        fileName: \"C:\\\\Users\\\\qwert\\\\Documents\\\\00_Coding\\\\sam_browser\\\\sam_browser\\\\app\\\\page.js\",\n        lineNumber: 286,\n        columnNumber: 5\n    }, this);\n}\n_s(HomePage, \"+dbC7Y7y5UQpbIdubwVRah45Qtg=\", false, function() {\n    return [\n        _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore,\n        useUserSettingsStore,\n        useSessionStateStore\n    ];\n});\n_c = HomePage;\nconst onDocumentTouchEndOrMouseUp = function() {\n    updateUserHasPinchZoomedIfChanged(false);\n};\nfunction updateUserHasPinchZoomedIfChanged(callAgainBoolean) {\n    //Update userhaspinchzoomed store, but only if the value has changed.\n    //(to prevent unnecessary rerenders)\n    const newUserHasPinchZoomed = calcUserHasPinchZoomed();\n    const oldUserHasPinchZoomed = _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore.getState().userHasPinchZoomed;\n    if (oldUserHasPinchZoomed !== newUserHasPinchZoomed) {\n        _stores_js__WEBPACK_IMPORTED_MODULE_4__.useUserHasPinchZoomedStore.getState().setUserHasPinchZoomed(newUserHasPinchZoomed);\n    }\n    if (callAgainBoolean) setTimeout(updateUserHasPinchZoomedIfChanged(false), 1000);\n}\n\n/* harmony default export */ const __WEBPACK_DEFAULT_EXPORT__ = (HomePage);\nvar _c;\n$RefreshReg$(_c, \"HomePage\");\n\n\n;\n    // Wrapped in an IIFE to avoid polluting the global scope\n    ;\n    (function () {\n        var _a, _b;\n        // Legacy CSS implementations will `eval` browser code in a Node.js context\n        // to extract CSS. For backwards compatibility, we need to check we're in a\n        // browser context before continuing.\n        if (typeof self !== 'undefined' &&\n            // AMP / No-JS mode does not inject these helpers:\n            '$RefreshHelpers$' in self) {\n            // @ts-ignore __webpack_module__ is global\n            var currentExports = module.exports;\n            // @ts-ignore __webpack_module__ is global\n            var prevSignature = (_b = (_a = module.hot.data) === null || _a === void 0 ? void 0 : _a.prevSignature) !== null && _b !== void 0 ? _b : null;\n            // This cannot happen in MainTemplate because the exports mismatch between\n            // templating and execution.\n            self.$RefreshHelpers$.registerExportsForReactRefresh(currentExports, module.id);\n            // A module can be accepted automatically based on its exports, e.g. when\n            // it is a Refresh Boundary.\n            if (self.$RefreshHelpers$.isReactRefreshBoundary(currentExports)) {\n                // Save the previous exports signature on update so we can compare the boundary\n                // signatures. We avoid saving exports themselves since it causes memory leaks (https://github.com/vercel/next.js/pull/53797)\n                module.hot.dispose(function (data) {\n                    data.prevSignature =\n                        self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports);\n                });\n                // Unconditionally accept an update to this module, we'll check if it's\n                // still a Refresh Boundary later.\n                // @ts-ignore importMeta is replaced in the loader\n                module.hot.accept();\n                // This field is set when the previous version of this module was a\n                // Refresh Boundary, letting us know we need to check for invalidation or\n                // enqueue an update.\n                if (prevSignature !== null) {\n                    // A boundary can become ineligible if its exports are incompatible\n                    // with the previous exports.\n                    //\n                    // For example, if you add/remove/change exports, we'll want to\n                    // re-execute the importing modules, and force those components to\n                    // re-render. Similarly, if you convert a class component to a\n                    // function, we want to invalidate the boundary.\n                    if (self.$RefreshHelpers$.shouldInvalidateReactRefreshBoundary(prevSignature, self.$RefreshHelpers$.getRefreshBoundarySignature(currentExports))) {\n                        module.hot.invalidate();\n                    }\n                    else {\n                        self.$RefreshHelpers$.scheduleUpdate();\n                    }\n                }\n            }\n            else {\n                // Since we just executed the code for the module, it's possible that the\n                // new exports made it ineligible for being a boundary.\n                // We only care about the case when we were _previously_ a boundary,\n                // because we already accepted this update (accidental side effect).\n                var isNoLongerABoundary = prevSignature !== null;\n                if (isNoLongerABoundary) {\n                    module.hot.invalidate();\n                }\n            }\n        }\n    })();\n//# sourceURL=[module]\n//# sourceMappingURL=data:application/json;charset=utf-8;base64,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SUFDMUQscUVBQXFFO0lBQ3JFLG9DQUFvQztJQUNwQyxNQUFNQyx3QkFBd0JsQztJQUM5QixNQUFNbUMsd0JBQXdCNUYsa0VBQTBCQSxDQUFDa0IsUUFBUSxHQUFHNEMsa0JBQWtCO0lBQ3RGLElBQUc4QiwwQkFBMEJELHVCQUFzQjtRQUNqRDNGLGtFQUEwQkEsQ0FBQ2tCLFFBQVEsR0FBRzZDLHFCQUFxQixDQUFDNEI7SUFDOUQ7SUFDQSxJQUFHRCxrQkFBa0JHLFdBQVlKLGtDQUFrQyxRQUFRO0FBQzdFO0FBRXNGO0FBQ3RGLGlFQUFleEIsUUFBUUEsRUFBQSIsInNvdXJjZXMiOlsiQzpcXFVzZXJzXFxxd2VydFxcRG9jdW1lbnRzXFwwMF9Db2RpbmdcXHNhbV9icm93c2VyXFxzYW1fYnJvd3NlclxcYXBwXFxwYWdlLmpzIl0sInNvdXJjZXNDb250ZW50IjpbIid1c2UgY2xpZW50J1xyXG4vLyAgICAgaWtlYjEwOC5naXRodWIuaW8vc2FtX2Jyb3dzZXIvb3V0XHJcbmltcG9ydCBSZWFjdCwgeyB1c2VFZmZlY3QgfSBmcm9tICdyZWFjdCdcclxuaW1wb3J0IHsgY3JlYXRlIH0gZnJvbSAnenVzdGFuZCdcclxuaW1wb3J0IFdvcmtzaGVldFZpZXdlciBmcm9tICcuL2NvbXBvbmVudHMvV29ya3NoZWV0Vmlld2VyLmpzJ1xyXG5pbXBvcnQgU2V0dGluZ3NQYWdlIGZyb20gJy4vY29tcG9uZW50cy9TZXR0aW5nc1BhZ2UuanMnXHJcbmltcG9ydCB7IHJldHJpZXZlV29ya3NoZWV0c0Zyb21JbmRleGVkREIsIHNldFN0YXR1c01lc3NhZ2VPZldvcmtzaGVldFByb2Nlc3MgfSBmcm9tIFwiLi9jb21wb25lbnRzL1NldHRpbmdzUGFnZS5qc1wiXHJcbmltcG9ydCB7IHVzZVVzZXJIYXNQaW5jaFpvb21lZFN0b3JlIH0gZnJvbSBcIi4vc3RvcmVzLmpzXCJcclxuaW1wb3J0IGNvbnN0YW50cyBmcm9tIFwiLi9jb25zdGFudHMuanNcIlxyXG5cclxuLy9LZXlzIGluIGFsbFBhZ2VzIHVzZSBQYXNjYWxDYXNpbmcgdG8gbWF0Y2ggdGhlIHJlYWN0IGNvbXBvbmVudCBuYW1lc1xyXG5jb25zdCBhbGxQYWdlcyA9IHtcclxuICBcIldvcmtzaGVldFZpZXdlclwiOiA8V29ya3NoZWV0Vmlld2VyIC8+LFxyXG4gIFwiU2V0dGluZ3NQYWdlXCI6IDxTZXR0aW5nc1BhZ2UgLz5cclxufVxyXG5cclxuLypcclxuY3JlYXRlKCkgaXMgYSBtZXRob2QgZnJvbSB0aGUgenVzdGFuZCBtb2R1bGUgZm9yIGVtdWxhdGluZyBnbG9iYWwgdmFyaWFibGVzLlxyXG4oU2ltcGxlciBhbHRlcm5hdGl2ZSB0byB1c2VDb250ZXh0LCB1c2VTdGF0ZSwgYW5kIHJlZHV4KS5cclxuXHJcbmNyZWF0ZSgpIHJldHVybnMgYSBcInN0b3JlIGhvb2tcIi0tYSBmdW5jdGlvbiB3aGljaCwgd2hlbiBjYWxsZWQsIHJldHVybnMgYSBcInN0b3JlXCIuXHJcblRoZSBcInN0b3JlXCIgaXMgYSBzdGF0ZSBjb250YWluZXIsIGFuIG9iamVjdCB3aGljaCBjYW4gaGF2ZSBhbnkgcHJvcGVydGllcyB5b3Ugd2FudC5cclxuVGhlc2UgcHJvcGVydGllcyBjb3VsZCBzdG9yZSBkYXRhIG9yIGNvdWxkIGJlIHVwZGF0ZXIgZnVuY3Rpb25zIChjYWxsZWQgXCJhY3Rpb25zXCIpLCBcclxud2hpY2ggY2FuIGNoYW5nZSBhcyBtYW55IG9yIGFzIGZldyBkYXRhIHByb3BlcnRpZXMgYXMgd2Ugd2FudC5cclxuXHJcbmNyZWF0ZSgpIGFjY2VwdHMgYSBmdW5jdGlvbiAoYSBcInN0b3JlIGluaXRpYWxpemVyXCIpLiBUaGUgc3RvcmUgaW5pdGlhbGl6ZXIgcmV0dXJuIGFuIG9iamVjdFxyXG53aGljaCBoYXMgYWxsIHRoZSBwcm9wZXJ0aWVzIGFuZCBhY3Rpb25zIHdlIHdhbnQgb3VyIHN0b3JlIHRvIGhhdmUuXHJcblxyXG5cIlN0b3JlIGhvb2tzXCIgc2hvdWxkIGJlIGRlY2xhcmVkIHdpdGggY29uc3QgaW4gdGhlIGdsb2JhbCBzY29wZS5cclxuVGhleSBjYW4gYmUgYXR0YWNoZWQgdG8gdGhlIFwid2luZG93XCIgb2JqZWN0IHRvIG1ha2UgdGhlbSBhY2Nlc3NpYmxlIGluIHRoZSBicm93c2VyIGNvbnNvbGUuXHJcblwiU3RvcmUgaG9va3NcIiBjYW4gb25seSBiZSAqY2FsbGVkKiBpbnNpZGUgYSBSZWFjdCBjb21wb25lbnQgKFJlYWN0IGhvb2tzIGFyZSBtZWFudCB0byB0cmlnZ2VyIGEgY29tcG9uZW50IHJlLXJlbmRlcikuXHJcblRvIGFjY2VzcyB0aGUgc3RvcmUgb3V0c2lkZSBhIGNvbXBvbmVudCwgY2FsbCBteVN0b3JlSG9vay5nZXRTdGF0ZSgpLiBGcm9tIHRoZXJlLCB5b3UgY2FuIHJlYWRcclxudGhlIHN0b3JlJ3MgcHJvcGVydGllcyBhbmQgY2FsbCB0aGUgc3RvcmUncyBhY3Rpb25zLlxyXG5cclxuKi9cclxuY29uc3QgY3JlYXRlQWxsU3R1ZGVudHNTdG9yZSA9IGZ1bmN0aW9uKHNldCl7IC8vU3RvcmUgaW5pdGlhbGl6ZXJcclxuICAvKlp1c3RhbmQgcGFzc2VzIGEgXCJzZXRcIiBmdW5jdGlvbiBpbnRvIGhlcmUuIFdlIGNhbGwgXCJzZXRcIlxyXG4gIHRvIHVwZGF0ZSBhbnkgcHJvcGVydGllcyBpbiB0aGUgc3RvcmUuIFdoZW4gd2UgY2FsbCBcInNldFwiLCB3ZSBwYXNzIFwic2V0XCJcclxuICBhIGZ1bmN0aW9uIHdoaWNoIHJldHVybnMgYSBcInBhcnRpYWwgc3RhdGVcIiwgYW4gb2JqZWN0IGNvbnRhaW5pbmcgYW55IG9mIHRoZSBwcm9wZXJ0aWVzIG9mIHRoZSBzdG9yZVxyXG4gIHdlIHdhbnQgdG8gY2hhbmdlLlxyXG4gIFdlIGNhbiBvcHRpb25hbGx5IG1ha2UgdGhhdCBmdW5jdGlvbiB0YWtlIHRoZSBwcmV2aW91cyBzdGF0ZSBhcyBhIHBhcmFtZXRlci5cclxuICAqL1xyXG4gIGNvbnN0IGdldEFsbFN0dWRlbnRzRnJvbUxvY2FsU3RvcmFnZSA9IGZ1bmN0aW9uKCl7XHJcbiAgICAvKlRoaXMgZnVuY3Rpb24gZGVmaW5lcyB0aGUgbG9naWMgZm9yIHRoZSBpbml0QWxsU3R1ZGVudHMgYWN0aW9uIChzZWUgYmVsb3cpLlxyXG4gICAgVGhpcyBmdW5jdGlvbiBkb2Vzbid0IHJlcXVpcmUgdGhlIHByZXZpb3VzIHN0YXRlIGFzIGEgcGFyYW1ldGVyLlxyXG4gICAgVGhpcyBmdW5jdGlvbiByZXR1cm5zIGEgXCJwYXJ0aWFsIHN0YXRlXCIgd2hpY2ggdXBkYXRlcyB0aGUgXCJhbGxTdHVkZW50c1wiIHByb3BlcnR5IG9mIHRoZSBzdG9yZS5cclxuICAgICovXHJcbiAgICBsZXQgYWxsU3R1ZGVudHNJbkxvY2FsU3RvcmFnZSA9IGxvY2FsU3RvcmFnZS5nZXRJdGVtKFwiYWxsU3R1ZGVudHNcIilcclxuICAgIGlmKGFsbFN0dWRlbnRzSW5Mb2NhbFN0b3JhZ2UgIT09IG51bGwpe1xyXG4gICAgICAvL2NvbnNvbGUubG9nKFwiRm91bmQgYWxsU3R1ZGVudHMgaW4gbG9jYWwgc3RvcmFnZS5cIilcclxuICAgICAgcmV0dXJuIHsgYWxsU3R1ZGVudHM6IEpTT04ucGFyc2UoYWxsU3R1ZGVudHNJbkxvY2FsU3RvcmFnZSkgfVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgLy9jb25zb2xlLmxvZyhcIkRpZG4ndCBmaW5kIGFsbFN0dWRlbnRzIGluIGxvY2FsIHN0b3JhZ2UuXCIpXHJcbiAgICAgIHJldHVybiB7IGFsbFN0dWRlbnRzOiB7fSB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHNldEFsbFN0dWRlbnRzVG9WYWx1ZSA9IGZ1bmN0aW9uKCBuZXdWYWx1ZSApe1xyXG4gICAgcmV0dXJuIHsgYWxsU3R1ZGVudHM6IG5ld1ZhbHVlIH1cclxuICB9XHJcbiAgXHJcbiAgcmV0dXJuIHtcclxuICAgIGFsbFN0dWRlbnRzOiB7fSxcclxuICAgIGluaXRBbGxTdHVkZW50czogKCk9PiB7IHNldChnZXRBbGxTdHVkZW50c0Zyb21Mb2NhbFN0b3JhZ2UpIH0sIC8vQWN0aW9uXHJcbiAgICAvKlxyXG4gICAgVGhlIGluaXRBbGxTdHVkZW50cygpIGFjdGlvbiBpcyBjYWxsZWQgaW4gSG9tZVBhZ2UoKSwgd2hlbiB0aGUgSG9tZVBhZ2UgY29tcG9uZW50XHJcbiAgICBpcyBtb3VudGVkIGZvciB0aGUgZmlyc3QgdGltZS4gVG8gZG8gdGhpcywgd2UgdXNlIEhvbWVQYWdlJ3MgdXNlRWZmZWN0KCkgaG9vaywgcGFzcyBpbiBhIGZ1bmN0aW9uXHJcbiAgICB0aGF0IGNhbGxzIGluaXRBbGxTdHVkZW50cygpLCBhbmQgYWxzbyBwYXNzIGluIGFuIGVtcHR5IGRlcGVuZGVuY3kgYXJyYXkgW10sIHdoaWNoIHRlbGxzIFJlYWN0IHRvIG9ubHlcclxuICAgIHJ1biB0aGF0IGZ1bmN0aW9uIG9uY2Ugd2hlbiB0aGUgY29tcG9uZW50IGlzIG1vdW50ZWQuXHJcbiAgICAqL1xyXG4gICBzZXRBbGxTdHVkZW50czogKG5ld1ZhbHVlKSA9PiB7IHNldCggc2V0QWxsU3R1ZGVudHNUb1ZhbHVlKG5ld1ZhbHVlKSApIH1cclxuICB9XHJcbn1cclxuXHJcbmNvbnN0IHVzZUFsbFN0dWRlbnRzU3RvcmUgPSBjcmVhdGUoY3JlYXRlQWxsU3R1ZGVudHNTdG9yZSkgLy9SZXR1cm5zIGEgc3RvcmUgaG9va1xyXG5cclxuLy9GaWxsZXIgZGF0YSBmb3IgZGVidWdnaW5nXHJcbmNvbnN0IGZpbGxlclN0dWRlbnREYXRhID0ge1xyXG4gIFwiMVwiOiB7IC8vaWQgbnVtYmVyIGZvciB0aGUgc3R1ZGVudCAodG8gYXZvaWQgZ2xpdGNoZXMgdyBzYW1lLW5hbWUgc3R1ZGVudHMpXHJcbiAgICBcIm5hbWVcIjogXCJTaWRvblwiLFxyXG4gICAgXCJjb2xvclwiOiBcInBpbmtcIlxyXG4gIH0sXHJcbiAgXCIyXCI6IHtcclxuICAgIFwibmFtZVwiOiBcIll1bm9ib1wiLFxyXG4gICAgXCJjb2xvclwiOiBcInB1cnBsZVwiXHJcbiAgfSxcclxuICBcIjNcIjoge1xyXG4gICAgXCJuYW1lXCI6IFwiVHVsaW5cIixcclxuICAgIFwiY29sb3JcIjogXCJibHVlXCJcclxuICB9XHJcbn1cclxudXNlQWxsU3R1ZGVudHNTdG9yZS5nZXRTdGF0ZSgpLnNldEFsbFN0dWRlbnRzKGZpbGxlclN0dWRlbnREYXRhKVxyXG5cclxuY29uc3QgdXNlU2Vzc2lvblN0YXRlU3RvcmUgPSBjcmVhdGUoIChzZXQpPT4gKHtcclxuICAvLyBvcGVuU3R1ZGVudHM6IHtcclxuICAvLyAgIFwiMlwiOiB7XHJcbiAgLy8gICAgIFwib3BlbldvcmtzaGVldHNcIjogW10sXHJcbiAgLy8gICAgIFwicG9zaXRpb25JbldvcmtzaGVldFNlbGVjdGlvblBhbmVsXCI6IDBcclxuICAvLyAgIH0sXHJcbiAgLy8gICBcIjFcIjoge1xyXG4gIC8vICAgICBcIm9wZW5Xb3Jrc2hlZXRzXCI6IFtdLFxyXG4gIC8vICAgICBcInBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbFwiOiAxXHJcbiAgLy8gICB9XHJcbiAgLy8gfSxcclxuICAvLyBoaWdoZXN0UG9zaXRpb25JbldvcmtzaGVldFNlbGVjdGlvblBhbmVsOiAxLFxyXG4gIC8vIGRlbGV0ZU9wZW5TdHVkZW50OiAoc3R1ZGVudElETnVtYmVyKT0+e1xyXG4gIC8vICAgbGV0IG5ld09wZW5TdHVkZW50cyA9IHsuLi51c2VTZXNzaW9uU3RhdGVTdG9yZS5nZXRTdGF0ZSgpLm9wZW5TdHVkZW50c31cclxuICAvLyAgIGRlbGV0ZSBuZXdPcGVuU3R1ZGVudHNbc3R1ZGVudElETnVtYmVyXVxyXG4gIC8vICAgc2V0KCAoKT0+KHsgb3BlblN0dWRlbnRzOiBuZXdPcGVuU3R1ZGVudHMgfSkgKVxyXG4gIC8vIH0sXHJcbiAgLy8gYWRkT3BlblN0dWRlbnRUb0JvdHRvbTogKHN0dWRlbnRJRE51bWJlcik9PntcclxuICAvLyAgIGxldCBuZXdPcGVuU3R1ZGVudHMgPSB7Li4udXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5vcGVuU3R1ZGVudHN9XHJcbiAgLy8gICBsZXQgaGlnaGVzdFBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbCA9IHVzZVNlc3Npb25TdGF0ZVN0b3JlLmdldFN0YXRlKCkuaGlnaGVzdFBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbFxyXG4gIC8vICAgbGV0IG5ld09wZW5TdHVkZW50ID0ge1xyXG4gIC8vICAgICBcIm9wZW5Xb3Jrc2hlZXRzXCI6IFtdLFxyXG4gIC8vICAgICBcInBvc2l0aW9uSW5Xb3Jrc2hlZXRTZWxlY3Rpb25QYW5lbFwiOiBoaWdoZXN0UG9zaXRpb25JbldvcmtzaGVldFNlbGVjdGlvblBhbmVsICsgMVxyXG4gIC8vICAgfVxyXG4gIC8vICAgbmV3T3BlblN0dWRlbnRzW3N0dWRlbnRJRE51bWJlcl0gPSBuZXdPcGVuU3R1ZGVudFxyXG4gIC8vICAgc2V0KCAoKT0+KHsgb3BlblN0dWRlbnRzOiBuZXdPcGVuU3R1ZGVudHMgfSkgKVxyXG4gIC8vICAgc2V0KCAoKSA9PiAoeyBoaWdoZXN0UG9zaXRpb25JbldvcmtzaGVldFNlbGVjdGlvblBhbmVsOiBoaWdoZXN0UG9zaXRpb25JbldvcmtzaGVldFNlbGVjdGlvblBhbmVsICsgMSB9KSApXHJcbiAgLy8gfVxyXG4gIG9wZW5TdHVkZW50czogW1xyXG4gICAge1wib3BlbldvcmtzaGVldHNcIjogWyBcclxuICAgICAge2lkOiBcIihPTEQpIDAzLjAxLTA1IEhGIChVU0EpIDEtMSBXU1wiLCBwYWdlTGVmdE9mZjogMH0sXHJcbiAgICAgIHtpZDogXCIoT0xEKSAwMy4wNi0xMiBUUCAoVVNBKSAxLTEgV1NcIiwgcGFnZUxlZnRPZmY6IDB9XHJcbiAgICBdLCBcInN0dWRlbnRJRE51bWJlclwiOiBcIjFcIn0sXHJcbiAgICB7XCJvcGVuV29ya3NoZWV0c1wiOiBbXSwgXCJzdHVkZW50SUROdW1iZXJcIjogXCIyXCJ9LFxyXG4gICAge1wib3BlbldvcmtzaGVldHNcIjogW10sIFwic3R1ZGVudElETnVtYmVyXCI6IFwiM1wifSxcclxuICAgIHtcIm9wZW5Xb3Jrc2hlZXRzXCI6IFtdLCBcInN0dWRlbnRJRE51bWJlclwiOiBcIm90aGVyXCJ9XHJcbiAgICAvLyB7XCJvcGVuV29ya3NoZWV0c1wiOiBbXSwgXCJzdHVkZW50SUROdW1iZXJcIjogXCIzXCJ9XHJcbiAgXSxcclxuICBzZXRPcGVuU3R1ZGVudHM6IChuZXdWYWx1ZSk9Pnsgc2V0KCAoKT0+KHsgb3BlblN0dWRlbnRzOiBuZXdWYWx1ZSB9KSApIH0sXHJcbiAgZGVsZXRlT3BlblN0dWRlbnQ6IChzdHVkZW50SUROdW1iZXIpPT57XHJcbiAgICAvKlxyXG4gICAgV2hlbiBkZWxldGluZyBhIHN0dWRlbnQsIHdlIG5lZWQgdG8gdXBkYXRlIHRoZSBvcGVuU3R1ZGVudEluZGV4IG9mIHRoZSBjdXJyZW50V29ya3NoZWV0XHJcbiAgICBiZWNhdXNlIHRoZSBvcGVuU3R1ZGVudHMgYXJyYXkgd2lsbCBiZSBzaG9ydGVyIGFmdGVyIHRoZSBzdHVkZW50IGlzIGRlbGV0ZWQuXHJcbiAgICBUbyBkbyB0aGlzLCB3ZSdsbCBncmFiIHRoZSBzdHVkZW50IElEIG51bWJlciBvZiB0aGUgc3R1ZGVudCBhdCBvcGVuU3R1ZGVudEluZGV4XHJcbiAgICBhbmQgdGhlbiB1c2UgdGhlIHN0dWRlbnQgSUQgbnVtYmVyIHRvIHJlc2V0IHRoZSBvcGVuU3R1ZGVudEluZGV4IGFmdGVyIGRlbGV0aW5nIHRoaXMgc3R1ZGVudC5cclxuICAgIFRoaXMgd29ya3MgYmVjYXVzZSB0aGVyZSB3aWxsIG5ldmVyIGJlIHR3byBTdHVkZW50U2Vzc2lvbkNhcmRzIHdpdGggdGhlIHNhbWUgc3R1ZGVudCBJRCBudW1iZXIuXHJcbiAgICAqL1xyXG4gICAgXHJcbiAgICAvL0dldCB0aGUgaWQgbnVtYmVyIG9mIHRoZSBzdHVkZW50IGF0IG9wZW5TdHVkZW50SW5kZXhcclxuICAgIGNvbnN0IHsgY3VycmVudFdvcmtzaGVldCwgb3BlblN0dWRlbnRzIH0gPSB1c2VTZXNzaW9uU3RhdGVTdG9yZS5nZXRTdGF0ZSgpXHJcbiAgICBjb25zb2xlLmxvZyggY3VycmVudFdvcmtzaGVldCwgb3BlblN0dWRlbnRzIClcclxuICAgIGNvbnN0IHN0dWRlbnRJRE51bWJlck9mT3BlblN0dWRlbnQgPSB1c2VTZXNzaW9uU3RhdGVTdG9yZS5nZXRTdGF0ZSgpLm9wZW5TdHVkZW50c1tjdXJyZW50V29ya3NoZWV0Lm9wZW5TdHVkZW50SW5kZXhdLnN0dWRlbnRJRE51bWJlclxyXG4gICAgY29uc29sZS5sb2coeyBzdHVkZW50SUROdW1iZXJPZk9wZW5TdHVkZW50IH0pXHJcbiAgICBsZXQgbmV3T3BlblN0dWRlbnRzID0gdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5vcGVuU3R1ZGVudHMuZmlsdGVyKCAoc3R1ZGVudCk9PiBzdHVkZW50LnN0dWRlbnRJRE51bWJlciAhPT0gc3R1ZGVudElETnVtYmVyIClcclxuICAgIHNldCggKCk9Pih7IG9wZW5TdHVkZW50czogbmV3T3BlblN0dWRlbnRzIH0pIClcclxuICAgIFxyXG4gICAgLy9Vc2UgdGhlIGlkIG51bWJlciB0byByZWRlZmluZSB0aGUgb3BlblN0dWRlbnRJbmRleFxyXG4gICAgY29uc3QgbmV3T3BlblN0dWRlbnRJbmRleCA9IG5ld09wZW5TdHVkZW50cy5maW5kSW5kZXgoIChzdHVkZW50KT0+IHN0dWRlbnQuc3R1ZGVudElETnVtYmVyID09PSBzdHVkZW50SUROdW1iZXJPZk9wZW5TdHVkZW50IClcclxuICAgIC8vSWYgbmV3T3BlblN0dWRlbnRJbmRleCBpcyAtMSwgdGhhdCBtZWFucyB0aGF0IHdlIGp1c3QgZGVsZXRlZCB0aGUgc3R1ZGVudCBhdCBvcGVuU3R1ZGVudEluZGV4XHJcbiAgICAvL1NvIHdlIG5lZWQgdG8gc2V0IG9wZW5TdHVkZW50SW5kZXggdG8gbnVsbFxyXG4gICAgaWYobmV3T3BlblN0dWRlbnRJbmRleCA9PT0gLTEpe1xyXG4gICAgICBzZXQoICgpPT4oeyBjdXJyZW50V29ya3NoZWV0OiB7IG9wZW5TdHVkZW50SW5kZXg6IG51bGwsIHdvcmtzaGVldEluZGV4OiBudWxsIH0gfSkgKVxyXG4gICAgfSBlbHNlIHtcclxuICAgICAgc2V0KCAoKT0+KHsgY3VycmVudFdvcmtzaGVldDogeyBvcGVuU3R1ZGVudEluZGV4OiBuZXdPcGVuU3R1ZGVudEluZGV4LCB3b3Jrc2hlZXRJbmRleDogY3VycmVudFdvcmtzaGVldC53b3Jrc2hlZXRJbmRleCB9IH0pIClcclxuICAgIH1cclxuICB9LFxyXG4gIGFkZE9wZW5TdHVkZW50VG9Cb3R0b206IChzdHVkZW50SUROdW1iZXIpPT57XHJcbiAgICBsZXQgbmV3T3BlblN0dWRlbnRzID0gdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKS5vcGVuU3R1ZGVudHMuY29uY2F0KHtcIm9wZW5Xb3Jrc2hlZXRzXCI6IFtdLCBcInN0dWRlbnRJRE51bWJlclwiOiBzdHVkZW50SUROdW1iZXJ9KVxyXG4gICAgc2V0KCAoKT0+KHsgb3BlblN0dWRlbnRzOiBuZXdPcGVuU3R1ZGVudHMgfSkgKVxyXG4gIH0sXHJcbiAgXHJcbiAgY3VycmVudFBhZ2U6IFwiV29ya3NoZWV0Vmlld2VyXCIsXHJcbiAgc2V0Q3VycmVudFBhZ2U6IChuZXdWYWx1ZSk9Pnsgc2V0KCAoKT0+KHsgY3VycmVudFBhZ2U6IG5ld1ZhbHVlIH0pICkgfSxcclxuICBjdXJyZW50V29ya3NoZWV0OiB7IG9wZW5TdHVkZW50SW5kZXg6IG51bGwsIHdvcmtzaGVldEluZGV4OiBudWxsIH0sXHJcbiAgc2V0Q3VycmVudFdvcmtzaGVldDogKG9wZW5TdHVkZW50SW5kZXgsIHdvcmtzaGVldEluZGV4KT0+eyBzZXQoICgpPT4oeyBjdXJyZW50V29ya3NoZWV0OiB7IG9wZW5TdHVkZW50SW5kZXg6IG9wZW5TdHVkZW50SW5kZXgsIHdvcmtzaGVldEluZGV4OiB3b3Jrc2hlZXRJbmRleCB9IH0pICkgfSxcclxuICBnZXRDdXJyZW50V29ya3NoZWV0SUQ6ICgpPT57XHJcbiAgICBjb25zdCB7IG9wZW5TdHVkZW50cywgY3VycmVudFdvcmtzaGVldCB9ID0gdXNlU2Vzc2lvblN0YXRlU3RvcmUuZ2V0U3RhdGUoKVxyXG4gICAgaWYoY3VycmVudFdvcmtzaGVldC5vcGVuU3R1ZGVudEluZGV4ID09PSBudWxsIHx8IGN1cnJlbnRXb3Jrc2hlZXQud29ya3NoZWV0SW5kZXggPT09IG51bGwpIHJldHVybiBudWxsXHJcbiAgICByZXR1cm4gb3BlblN0dWRlbnRzW2N1cnJlbnRXb3Jrc2hlZXQub3BlblN0dWRlbnRJbmRleF0ub3BlbldvcmtzaGVldHNbY3VycmVudFdvcmtzaGVldC53b3Jrc2hlZXRJbmRleF0uaWRcclxuICB9LFxyXG4gIHVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQ6IGZhbHNlLFxyXG4gIHNldFVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQ6IChuZXdWYWx1ZSk9Pnsgc2V0KCAoKT0+KHsgdXNlcklzTW92aW5nQ3VycmVudFdvcmtzaGVldDogbmV3VmFsdWUgfSkgKSB9LFxyXG4gIHVzZXJDYW5DbGlja0FueXdoZXJlVG9EaXNhYmxlTW92aW5nQ3VycmVudFdvcmtzaGVldDogZmFsc2UsXHJcbiAgc2V0VXNlckNhbkNsaWNrQW55d2hlcmVUb0Rpc2FibGVNb3ZpbmdDdXJyZW50V29ya3NoZWV0OiAobmV3VmFsdWUpPT57IHNldCggKCk9Pih7IHVzZXJDYW5DbGlja0FueXdoZXJlVG9EaXNhYmxlTW92aW5nQ3VycmVudFdvcmtzaGVldDogbmV3VmFsdWUgfSkgKSB9LFxyXG4gIGN1cnJlbnRQYWdlT2ZXb3Jrc2hlZXQ6IDAsIC8vVmFsdWUgb2YgdGhlIHBhZ2Ugb24gdGhlIGxlZnRcclxuICBzZXRDdXJyZW50UGFnZU9mV29ya3NoZWV0OiAobmV3VmFsdWUpPT57IFxyXG4gICAgc2V0KCAoKT0+KHsgY3VycmVudFBhZ2VPZldvcmtzaGVldDogbmV3VmFsdWUgfSkgKVxyXG4gICAgY29uc3QgeyBvcGVuU3R1ZGVudHMsIGN1cnJlbnRXb3Jrc2hlZXQgfSA9IHVzZVNlc3Npb25TdGF0ZVN0b3JlLmdldFN0YXRlKClcclxuICAgIGlmIChjdXJyZW50V29ya3NoZWV0Lm9wZW5TdHVkZW50SW5kZXggIT09IG51bGwgJiYgY3VycmVudFdvcmtzaGVldC53b3Jrc2hlZXRJbmRleCAhPT0gbnVsbCkge1xyXG4gICAgICBvcGVuU3R1ZGVudHNbY3VycmVudFdvcmtzaGVldC5vcGVuU3R1ZGVudEluZGV4XS5vcGVuV29ya3NoZWV0c1tjdXJyZW50V29ya3NoZWV0LndvcmtzaGVldEluZGV4XS5wYWdlTGVmdE9mZiA9IG5ld1ZhbHVlXHJcbiAgICAgIHNldCh7IG9wZW5TdHVkZW50czogWy4uLm9wZW5TdHVkZW50c10gfSlcclxuICAgIH1cclxuICB9LFxyXG4gIGFsbG93QXJyb3dLZXlzRm9yUGFnZU5hdmlnYXRpb246IHRydWUsXHJcbiAgc2V0QWxsb3dBcnJvd0tleXNGb3JQYWdlTmF2aWdhdGlvbjogKG5ld1ZhbHVlKT0+eyBzZXQoICgpPT4oeyBhbGxvd0Fycm93S2V5c0ZvclBhZ2VOYXZpZ2F0aW9uOiBuZXdWYWx1ZSB9KSApIH0sXHJcbn0pKVxyXG5cclxuY29uc3QgdXNlVXNlclNldHRpbmdzU3RvcmUgPSBjcmVhdGUoIChzZXQpPT4gKHtcclxuICAvL3NldHRpbmdzIGdvIGhlcmVcclxuICBwYWdlVmlldzogXCJkb3VibGVcIiwgLy9zaW5nbGUgb3IgZG91YmxlXHJcbiAgc2V0UGFnZVZpZXc6IChuZXdWYWx1ZSk9Pnsgc2V0KCAoKT0+KHsgcGFnZVZpZXc6IG5ld1ZhbHVlIH0pICkgfSxcclxuICBtYWRpc29uTW9kZTogZmFsc2UsXHJcbiAgc2V0TWFkaXNvbk1vZGU6IChuZXdWYWx1ZSk9Pnsgc2V0KCAoKT0+KHsgbWFkaXNvbk1vZGU6IG5ld1ZhbHVlIH0pICkgfVxyXG59KSlcclxuXHJcbmV4cG9ydCBmdW5jdGlvbiBjYWxjVXNlckhhc1BpbmNoWm9vbWVkKCl7XHJcbiAgLy9jYWxjdWxhdGVzIHdoZXRoZXIgdGhlIHVzZXIgaGFzIHBpbmNoIHpvb21lZCBvbiB0aGUgcGFnZVxyXG4gIHJldHVybiB3aW5kb3cudmlzdWFsVmlld3BvcnQuc2NhbGUgIT09IDFcclxufVxyXG5cclxuZnVuY3Rpb24gdXBkYXRlVXNlckhhc1BpbmNoWm9vbWVkT25SZXNpemUoKXtcclxuICAvL0lmIHRoZSB1c2VyIGhhcyBwaW5jaCB6b29tZWQsIHNldCB0aGUgc3RvcmUgdG8gdHJ1ZSxcclxuICAvL2J1dCBvbmx5IGlmIGl0J3Mgbm90IGFscmVhZHkgc2V0IHRvIHRydWUuIE90aGVyd2lzZSwgc2V0dGluZyBpdCB0byB0cnVlXHJcbiAgLy93b3VsZCBjYXVzZSB1bm5lY2Vzc2FyeSByZXJlbmRlcnMgb2YgdGhlIGVudGlyZSBIb21lUGFnZSBkdXJpbmcgZXZlcnkgZnJhbWUgb2YgcGluY2ggem9vbSBnZXN0dXJlLlxyXG4gIGlmKCBjYWxjVXNlckhhc1BpbmNoWm9vbWVkKCkgKXtcclxuICAgIGlmKCF1c2VVc2VySGFzUGluY2hab29tZWRTdG9yZS5nZXRTdGF0ZSgpLnVzZXJIYXNQaW5jaFpvb21lZCl7XHJcbiAgICAgIHVzZVVzZXJIYXNQaW5jaFpvb21lZFN0b3JlLmdldFN0YXRlKCkuc2V0VXNlckhhc1BpbmNoWm9vbWVkKHRydWUpXHJcbiAgICB9XHJcbiAgfVxyXG4gIC8vSWYgdGhlIHVzZXIgaGFzIG5vdCBwaW5jaCB6b29tZWQsIHRoZSB1c2VySGFzUGluY2hab29tZWQgc3RhdGUgc2hvdWxkbid0IGJlIHNldCB0byBmYWxzZSB1bnRpbCB0b3VjaGVuZC5cclxuICAvL090aGVyd2lzZSwgdGhlIHVzZXIgY291bGQgdHJpZ2dlciBkcmFnIGV2ZW50cyB3aGlsZSBwaW5jaCB6b29taW5nIGlmIGl0J3Mgem9vbWVkIGFsbCB0aGUgd2F5IG91dC5cclxufVxyXG5cclxuY29uc3Qgd29ya3NoZWV0cyA9IHt9XHJcblxyXG5mdW5jdGlvbiBIb21lUGFnZSgpIHtcclxuICBjb25zdCB7IHVzZXJIYXNQaW5jaFpvb21lZCB9ID0gdXNlVXNlckhhc1BpbmNoWm9vbWVkU3RvcmUoKVxyXG4gIGNvbnN0IHsgcGFnZVZpZXcgfSA9IHVzZVVzZXJTZXR0aW5nc1N0b3JlKClcclxuICAvL1RoZSBmdW5jdGlvbiBpbiB0aGlzIHVzZUVmZmVjdCB3aWxsIHJ1biBldmVyeSB0aW1lIEhvbWVQYWdlIGlzIHJlcmVuZGVyZWQsXHJcbiAgLy93aGljaCB3aWxsIGhhcHBlbiBldmVyeSB0aW1lIHVzZXJIYXNQaW5jaFpvb21lZCBjaGFuZ2VzLCB3aGljaCBzaG91bGQgYmVcclxuICAvL2F0IHRoZSBzdGFydCBhbmQgZW5kIG9mIHBpbmNoIHpvb20gZ2VzdHVyZXMsIGJ1dCBub3QgaW4gYmV0d2Vlbi5cclxuICB1c2VFZmZlY3QoICgpPT57XHJcbiAgICAvL1RoZXNlIGV2ZW50IGxpc3RlbmVycyBnZXQgYWRkZWQgZXZlcnkgdGltZSB0aGUgY29tcG9uZW50IGlzIHJlcmVuZGVyZWQuXHJcbiAgICAvL1RvIHByZXZlbnQgZXZlbnQgbGlzdGVuZXJzIGZyb20gYWNjdW11bGF0aW5nLCB0aGV5IGdldCByZW1vdmVkIHdoZW4gdGhlIGNvbXBvbmVudCB1bm1vdW50c1xyXG4gICAgLy92aWEgdGhlIGNsZWFudXAgZnVuY3Rpb24gdGhhdCBpcyByZXR1cm5lZCBiZWxvdy5cclxuICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5hZGRFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZVVzZXJIYXNQaW5jaFpvb21lZE9uUmVzaXplKVxyXG4gICAgZG9jdW1lbnQuYWRkRXZlbnRMaXN0ZW5lcihcInRvdWNoZW5kXCIsIG9uRG9jdW1lbnRUb3VjaEVuZE9yTW91c2VVcClcclxuICAgIGRvY3VtZW50LmFkZEV2ZW50TGlzdGVuZXIoXCJtb3VzZXVwXCIsIG9uRG9jdW1lbnRUb3VjaEVuZE9yTW91c2VVcClcclxuICAgIHVwZGF0ZVVzZXJIYXNQaW5jaFpvb21lZE9uUmVzaXplKClcclxuICAgIFxyXG4gICAgaW1wb3J0KFwiZXJ1ZGFcIikudGhlbiAoIChtb2R1bGUpID0+IHsgbW9kdWxlLmRlZmF1bHQuaW5pdCgpIH0pXHJcbiAgICBcclxuICAgIC8vIHdpbmRvdy5lcnVkYSA9IGVydWRhXHJcbiAgICByZXR1cm4gKCk9PiB7XHJcbiAgICAgIHdpbmRvdy52aXN1YWxWaWV3cG9ydC5yZW1vdmVFdmVudExpc3RlbmVyKFwicmVzaXplXCIsIHVwZGF0ZVVzZXJIYXNQaW5jaFpvb21lZE9uUmVzaXplKVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwidG91Y2hlbmRcIiwgb25Eb2N1bWVudFRvdWNoRW5kT3JNb3VzZVVwKVxyXG4gICAgICBkb2N1bWVudC5yZW1vdmVFdmVudExpc3RlbmVyKFwibW91c2V1cFwiLCBvbkRvY3VtZW50VG91Y2hFbmRPck1vdXNlVXApXHJcbiAgICB9XHJcbiAgfSwgW10pXHJcbiAgXHJcbiAgY29uc3QgaG9tZVBhZ2VTdHlsZSA9IHtcclxuICAgIGZvbnRGYW1pbHk6IFwiUm9ib3RvLCBzYW5zLXNlcmlmXCIsXHJcbiAgICBmb250V2VpZ2h0OiBcIm5vcm1hbFwiLFxyXG4gICAgZm9udFNpemU6IFwiMThweFwiLFxyXG4gICAgaGVpZ2h0OiBcIjEwMCVcIixcclxuICAgIHdpZHRoOiBcIjEwMCVcIixcclxuICAgIG1heFdpZHRoOiAocGFnZVZpZXcgPT0gXCJkb3VibGVcIikgPyBcIjE1MDBweFwiIDogXCIxMDAwcHhcIixcclxuICAgIGNvbG9yOiBjb25zdGFudHMubmVhckJsYWNrQ29sb3IsXHJcbiAgICB0b3VjaEFjdGlvbjogdXNlckhhc1BpbmNoWm9vbWVkID8gXCJhdXRvXCIgOiBcInBpbmNoLXpvb21cIiwgLy9JZiB0aGUgdXNlciBoYXMgcGluY2ggem9vbWVkLCBhbGxvdyBwYW5uaW5nLiBJZiBub3QsIGRpc2FibGUgcGFubmluZ1xyXG4gICAgbWFyZ2luOiBcIjAgYXV0b1wiXHJcbiAgfVxyXG4gIFxyXG4gIGNvbnN0IHNlc3Npb25TdGF0ZVN0b3JlID0gdXNlU2Vzc2lvblN0YXRlU3RvcmUoKVxyXG4gIGNvbnN0IGN1cnJlbnRQYWdlID0gc2Vzc2lvblN0YXRlU3RvcmUuY3VycmVudFBhZ2VcclxuICAvKlxyXG4gIFdoZW4gSG9tZVBhZ2UgbW91bnRzIGZvciB0aGUgZmlyc3QgdGltZSwgaW5pdGlhbGl6ZSBhbGxTdHVkZW50c1N0b3JlIGJ5IGdyYWJiaW5nXHJcbiAgYWxsU3R1ZGVudHMgZnJvbSBsb2NhbFN0b3JhZ2UuIFBhc3MgYW4gZW1wdHkgZGVwZW5kZW5jeSBhcnJheSBbXSBpbnRvIHVzZUVmZmVjdCB0byB0ZWxsIFJlYWN0XHJcbiAgdG8gb25seSBydW4gdGhpcyBjb2RlIHRoZSBmaXJzdCB0aW1lIEhvbWVQYWdlIG1vdW50cy5cclxuICAqL1xyXG4gIHVzZUVmZmVjdCggKCk9PntcclxuICAgIC8vdXNlQWxsU3R1ZGVudHNTdG9yZS5nZXRTdGF0ZSgpLmluaXRBbGxTdHVkZW50cygpO1xyXG4gICAgd2luZG93LnVzZUFsbFN0dWRlbnRzU3RvcmUgPSB1c2VBbGxTdHVkZW50c1N0b3JlOyAvL2NhbGwgdXNlQWxsU3R1ZGVudHNTdG9yZS5nZXRTdGF0ZSgpIHdoZW4gYWNjZXNzaW5nIGluIHRoZSBkZXYgY29uc29sZS5cclxuICAgIHdpbmRvdy51c2VTZXNzaW9uU3RhdGVTdG9yZSA9IHVzZVNlc3Npb25TdGF0ZVN0b3JlO1xyXG4gICAgd2luZG93LnVzZVVzZXJTZXR0aW5nc1N0b3JlID0gdXNlVXNlclNldHRpbmdzU3RvcmU7XHJcbiAgICBcclxuICAgIC8vT24gcGFnZSBsb2FkLCByZXRyaWV2ZSB3b3Jrc2hlZXRzIGZyb20gSW5kZXhlZERCIGlmIGFueS4gVGhpcyBmdW5jdGlvbiBpcyBpbXBvcnRlZCBmcm9tIFNldHRpbmdzUGFnZS5qc1xyXG4gICAgcmV0cmlldmVXb3Jrc2hlZXRzRnJvbUluZGV4ZWREQigpXHJcbiAgfSwgW10pXHJcbiAgLypcclxuICBUaGUgZGVwZW5kZW5jeSBhcnJheSB3ZSBwYXNzIGludG8gdXNlRWZmZWN0IHRlbGxzIFJlYWN0IHdoaWNoIHZhcmlhYmxlcyB0byBsb29rXHJcbiAgZm9yIGNoYW5nZXMgaW4uIFdoZW4gYW55IG9mIHRoZXNlIHZhcmlhYmxlcyBjaGFuZ2UsIHRoZSBmdW5jdGlvbiBpbiB1c2VFZmZlY3QoKSBpc1xyXG4gIHRyaWdnZXJlZC4gRW1wdHkgPSBydW4gb25seSBvbmNlIChvbiBjb21wb25lbnQgbW91bnQpLlxyXG4gICovXHJcbiAgY29uc3Qgb25DbGljayA9IGZ1bmN0aW9uKCl7XHJcbiAgICBpZihjdXJyZW50UGFnZSA9PSBcIldvcmtzaGVldFZpZXdlclwiKXtcclxuICAgICAgaWYoc2Vzc2lvblN0YXRlU3RvcmUudXNlcklzTW92aW5nQ3VycmVudFdvcmtzaGVldCAmJiBzZXNzaW9uU3RhdGVTdG9yZS51c2VyQ2FuQ2xpY2tBbnl3aGVyZVRvRGlzYWJsZU1vdmluZ0N1cnJlbnRXb3Jrc2hlZXQpe1xyXG4gICAgICAgIHNlc3Npb25TdGF0ZVN0b3JlLnNldFVzZXJJc01vdmluZ0N1cnJlbnRXb3Jrc2hlZXQoZmFsc2UpXHJcbiAgICAgICAgc2Vzc2lvblN0YXRlU3RvcmUuc2V0VXNlckNhbkNsaWNrQW55d2hlcmVUb0Rpc2FibGVNb3ZpbmdDdXJyZW50V29ya3NoZWV0KGZhbHNlKVxyXG4gICAgICB9XHJcbiAgICB9XHJcbiAgfVxyXG4gIHJldHVybiAoXHJcbiAgICA8ZGl2IHN0eWxlPXtob21lUGFnZVN0eWxlfSBvbkNsaWNrPXtvbkNsaWNrfT5cclxuICAgICAge2FsbFBhZ2VzW2N1cnJlbnRQYWdlXX1cclxuICAgIDwvZGl2PlxyXG4gIClcclxufVxyXG5cclxuY29uc3Qgb25Eb2N1bWVudFRvdWNoRW5kT3JNb3VzZVVwID0gZnVuY3Rpb24oKXtcclxuICB1cGRhdGVVc2VySGFzUGluY2hab29tZWRJZkNoYW5nZWQoZmFsc2UpXHJcbn1cclxuXHJcbmZ1bmN0aW9uIHVwZGF0ZVVzZXJIYXNQaW5jaFpvb21lZElmQ2hhbmdlZCggY2FsbEFnYWluQm9vbGVhbiApe1xyXG4gIC8vVXBkYXRlIHVzZXJoYXNwaW5jaHpvb21lZCBzdG9yZSwgYnV0IG9ubHkgaWYgdGhlIHZhbHVlIGhhcyBjaGFuZ2VkLlxyXG4gIC8vKHRvIHByZXZlbnQgdW5uZWNlc3NhcnkgcmVyZW5kZXJzKVxyXG4gIGNvbnN0IG5ld1VzZXJIYXNQaW5jaFpvb21lZCA9IGNhbGNVc2VySGFzUGluY2hab29tZWQoKVxyXG4gIGNvbnN0IG9sZFVzZXJIYXNQaW5jaFpvb21lZCA9IHVzZVVzZXJIYXNQaW5jaFpvb21lZFN0b3JlLmdldFN0YXRlKCkudXNlckhhc1BpbmNoWm9vbWVkXHJcbiAgaWYob2xkVXNlckhhc1BpbmNoWm9vbWVkICE9PSBuZXdVc2VySGFzUGluY2hab29tZWQpe1xyXG4gICAgdXNlVXNlckhhc1BpbmNoWm9vbWVkU3RvcmUuZ2V0U3RhdGUoKS5zZXRVc2VySGFzUGluY2hab29tZWQobmV3VXNlckhhc1BpbmNoWm9vbWVkKVxyXG4gIH1cclxuICBpZihjYWxsQWdhaW5Cb29sZWFuKSBzZXRUaW1lb3V0KCB1cGRhdGVVc2VySGFzUGluY2hab29tZWRJZkNoYW5nZWQoZmFsc2UpLCAxMDAwIClcclxufVxyXG5cclxuZXhwb3J0IHsgdXNlQWxsU3R1ZGVudHNTdG9yZSwgdXNlU2Vzc2lvblN0YXRlU3RvcmUsIHVzZVVzZXJTZXR0aW5nc1N0b3JlLCB3b3Jrc2hlZXRzIH1cclxuZXhwb3J0IGRlZmF1bHQgSG9tZVBhZ2VcclxuIl0sIm5hbWVzIjpbIlJlYWN0IiwidXNlRWZmZWN0IiwiY3JlYXRlIiwiV29ya3NoZWV0Vmlld2VyIiwiU2V0dGluZ3NQYWdlIiwicmV0cmlldmVXb3Jrc2hlZXRzRnJvbUluZGV4ZWREQiIsInNldFN0YXR1c01lc3NhZ2VPZldvcmtzaGVldFByb2Nlc3MiLCJ1c2VVc2VySGFzUGluY2hab29tZWRTdG9yZSIsImNvbnN0YW50cyIsImFsbFBhZ2VzIiwiY3JlYXRlQWxsU3R1ZGVudHNTdG9yZSIsInNldCIsImdldEFsbFN0dWRlbnRzRnJvbUxvY2FsU3RvcmFnZSIsImFsbFN0dWRlbnRzSW5Mb2NhbFN0b3JhZ2UiLCJsb2NhbFN0b3JhZ2UiLCJnZXRJdGVtIiwiYWxsU3R1ZGVudHMiLCJKU09OIiwicGFyc2UiLCJzZXRBbGxTdHVkZW50c1RvVmFsdWUiLCJuZXdWYWx1ZSIsImluaXRBbGxTdHVkZW50cyIsInNldEFsbFN0dWRlbnRzIiwidXNlQWxsU3R1ZGVudHNTdG9yZSIsImZpbGxlclN0dWRlbnREYXRhIiwiZ2V0U3RhdGUiLCJ1c2VTZXNzaW9uU3RhdGVTdG9yZSIsIm9wZW5TdHVkZW50cyIsImlkIiwicGFnZUxlZnRPZmYiLCJzZXRPcGVuU3R1ZGVudHMiLCJkZWxldGVPcGVuU3R1ZGVudCIsInN0dWRlbnRJRE51bWJlciIsImN1cnJlbnRXb3Jrc2hlZXQiLCJjb25zb2xlIiwibG9nIiwic3R1ZGVudElETnVtYmVyT2ZPcGVuU3R1ZGVudCIsIm9wZW5TdHVkZW50SW5kZXgiLCJuZXdPcGVuU3R1ZGVudHMiLCJmaWx0ZXIiLCJzdHVkZW50IiwibmV3T3BlblN0dWRlbnRJbmRleCIsImZpbmRJbmRleCIsIndvcmtzaGVldEluZGV4IiwiYWRkT3BlblN0dWRlbnRUb0JvdHRvbSIsImNvbmNhdCIsImN1cnJlbnRQYWdlIiwic2V0Q3VycmVudFBhZ2UiLCJzZXRDdXJyZW50V29ya3NoZWV0IiwiZ2V0Q3VycmVudFdvcmtzaGVldElEIiwib3BlbldvcmtzaGVldHMiLCJ1c2VySXNNb3ZpbmdDdXJyZW50V29ya3NoZWV0Iiwic2V0VXNlcklzTW92aW5nQ3VycmVudFdvcmtzaGVldCIsInVzZXJDYW5DbGlja0FueXdoZXJlVG9EaXNhYmxlTW92aW5nQ3VycmVudFdvcmtzaGVldCIsInNldFVzZXJDYW5DbGlja0FueXdoZXJlVG9EaXNhYmxlTW92aW5nQ3VycmVudFdvcmtzaGVldCIsImN1cnJlbnRQYWdlT2ZXb3Jrc2hlZXQiLCJzZXRDdXJyZW50UGFnZU9mV29ya3NoZWV0IiwiYWxsb3dBcnJvd0tleXNGb3JQYWdlTmF2aWdhdGlvbiIsInNldEFsbG93QXJyb3dLZXlzRm9yUGFnZU5hdmlnYXRpb24iLCJ1c2VVc2VyU2V0dGluZ3NTdG9yZSIsInBhZ2VWaWV3Iiwic2V0UGFnZVZpZXciLCJtYWRpc29uTW9kZSIsInNldE1hZGlzb25Nb2RlIiwiY2FsY1VzZXJIYXNQaW5jaFpvb21lZCIsIndpbmRvdyIsInZpc3VhbFZpZXdwb3J0Iiwic2NhbGUiLCJ1cGRhdGVVc2VySGFzUGluY2hab29tZWRPblJlc2l6ZSIsInVzZXJIYXNQaW5jaFpvb21lZCIsInNldFVzZXJIYXNQaW5jaFpvb21lZCIsIndvcmtzaGVldHMiLCJIb21lUGFnZSIsImFkZEV2ZW50TGlzdGVuZXIiLCJkb2N1bWVudCIsIm9uRG9jdW1lbnRUb3VjaEVuZE9yTW91c2VVcCIsInRoZW4iLCJtb2R1bGUiLCJkZWZhdWx0IiwiaW5pdCIsInJlbW92ZUV2ZW50TGlzdGVuZXIiLCJob21lUGFnZVN0eWxlIiwiZm9udEZhbWlseSIsImZvbnRXZWlnaHQiLCJmb250U2l6ZSIsImhlaWdodCIsIndpZHRoIiwibWF4V2lkdGgiLCJjb2xvciIsIm5lYXJCbGFja0NvbG9yIiwidG91Y2hBY3Rpb24iLCJtYXJnaW4iLCJzZXNzaW9uU3RhdGVTdG9yZSIsIm9uQ2xpY2siLCJkaXYiLCJzdHlsZSIsInVwZGF0ZVVzZXJIYXNQaW5jaFpvb21lZElmQ2hhbmdlZCIsImNhbGxBZ2FpbkJvb2xlYW4iLCJuZXdVc2VySGFzUGluY2hab29tZWQiLCJvbGRVc2VySGFzUGluY2hab29tZWQiLCJzZXRUaW1lb3V0Il0sImlnbm9yZUxpc3QiOltdLCJzb3VyY2VSb290IjoiIn0=\n//# sourceURL=webpack-internal:///(app-pages-browser)/./app/page.js\n"));

/***/ })

});